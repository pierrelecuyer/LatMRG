<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatMRG API Documentation: LatticeTester Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatMRG API Documentation<span id="projectnumber">&#160;unknown</span>
   </div>
   <div id="projectbrief">Tools to analyze the lattice structure of linear generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d74/namespaceLatticeTester.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">LatticeTester Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/namespaceLatticeTester_1_1CoordinateSets.html">CoordinateSets</a></td></tr>
<tr class="memdesc:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="mdescLeft">&#160;</td><td class="mdescRight">The classes <code>FromRange</code>, <code>SubSets</code>, and <code><a class="el" href="../../d7/d31/classLatticeTester_1_1CoordinateSets_1_1AddCoordinate.html" title="This template class wraps any implementation of a CoordinateSets and adds a specific coordinate to ea...">AddCoordinate</a></code> are defined here. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d32/classLatticeTester_1_1Chrono.html">Chrono</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides <code><a class="el" href="../../d9/d32/classLatticeTester_1_1Chrono.html" title="This class provides Chrono objects that act as stopwatches that use the system clock to compute the C...">Chrono</a></code> objects that act as stopwatches that use the system clock to compute the CPU time used by parts of a program.  <a href="../../d9/d32/classLatticeTester_1_1Chrono.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object type that contains a set of coordinate indices, used to specify a projection.  <a href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ddf/classLatticeTester_1_1FigureOfMeritDualM.html">FigureOfMeritDualM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers tools to calculate the same figure of merit (FOM) as <code>FigureOfMerit</code>, but for the m-duals of the projections.  <a href="../../d4/ddf/classLatticeTester_1_1FigureOfMeritDualM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dca/classLatticeTester_1_1FigureOfMeritM.html">FigureOfMeritM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides tools to calculate the <em>figure of merit</em> (FOM) \( M_{t_1,\dots,t_d}\) for any given <code><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html" title="This abstract class extends IntLattice and is a skeleton for the specialized subclasses that define s...">IntLatticeExt</a></code> object.  <a href="../../d7/dca/classLatticeTester_1_1FigureOfMeritM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">IntLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a></code> object is an integral lattice, with its basis or its <code>m</code>-dual basis, or both.  <a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html">IntLatticeExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class extends <code><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a></code> and is a skeleton for the specialized subclasses that define specific types of lattices.  <a href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d4e/classLatticeTester_1_1MRGLattice.html">MRGLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subclass of <code><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html" title="This abstract class extends IntLattice and is a skeleton for the specialized subclasses that define s...">IntLatticeExt</a></code> defines an MRG lattice.  <a href="../../d9/d4e/classLatticeTester_1_1MRGLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html">NormaBestLat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html" title="This is a base class for implementing normalization constants used in figures of merit,...">Normalizer</a> class implements approximate upper bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d61/classLatticeTester_1_1NormaBestUpBound.html">NormaBestUpBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this normalizer, the Hermite constants \(\gamma_s\) are approximated using the best upper bounds that are available.  <a href="../../d2/d61/classLatticeTester_1_1NormaBestUpBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html">NormaLaminated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html" title="This is a base class for implementing normalization constants used in figures of merit,...">Normalizer</a> class implements approximate upper bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html">Normalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base class for implementing normalization constants used in figures of merit, to normalize the length of the shortest nonzero vector in either the primal or dual lattice.  <a href="../../d0/dc8/classLatticeTester_1_1Normalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d78/classLatticeTester_1_1NormaMinkHlaw.html">NormaMinkHlaw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <em>lower bounds</em> on the Hermite constants based on the Minkowski-Hlawka theorem <b>[mHLA43a]</b>.  <a href="../../df/d78/classLatticeTester_1_1NormaMinkHlaw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html">NormaPalpha</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the values of \(P_{\alpha}\) for a lattice (see class <code>Palpha</code>).  <a href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d30/classLatticeTester_1_1NormaRogers.html">NormaRogers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the length of the shortest nonzero vector in a lattice, in which the Hermite constants \(\gamma_s\) are approximated by their Rogers's bounds.  <a href="../../d1/d30/classLatticeTester_1_1NormaRogers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subclass of <code><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html" title="This abstract class extends IntLattice and is a skeleton for the specialized subclasses that define s...">IntLatticeExt</a></code> defines a general rank 1 lattice rule in \(t\) dimensions, whose points \(\mathbb{u}_i\) are defined by \( \mathbf{u}_i = (i \mathbf{a} \bmod m)/m \) where \(\mathbf{a} = (a_1,a_2,\dots,a_t) \in \mathbb{Z}_m^t\) is the generating vector; see Section 5.4 of the guide.  <a href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dea/classLatticeTester_1_1ReducerBB.html">ReducerBB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functions to find a shortest nonzero vector in the lattice using a BB algorithm as in <b>[mFIN85a]</b>, and to compute a Minkowski basis reduction as in <b>[rAFF85a]</b>.  <a href="../../d0/dea/classLatticeTester_1_1ReducerBB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines an interface to specify <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html" title="Abstract class that defines an interface to specify Weights given to projections in figures of merit.">Weights</a> given to projections in figures of merit.  <a href="../../db/d40/classLatticeTester_1_1Weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7f/classLatticeTester_1_1WeightsOrderDependent.html">WeightsOrderDependent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines order-dependent weights, for which the weight of a projection depends only on its order (cardinality).  <a href="../../dd/d7f/classLatticeTester_1_1WeightsOrderDependent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0e/classLatticeTester_1_1WeightsPOD.html">WeightsPOD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines product and order-dependent (POD) weights, for which the weight of a projection is the sum of a product weight and an order-dependent weight.  <a href="../../d8/d0e/classLatticeTester_1_1WeightsPOD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d8a/classLatticeTester_1_1WeightsProduct.html">WeightsProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines product weights, for which the weight of a projection is equal to the product of the weights of the individual coordinates.  <a href="../../d1/d8a/classLatticeTester_1_1WeightsProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html">WeightsProjectionDependent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines projection-dependent weights, for which the weight for any given projection can be set individually by <a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html#a18af3f94aaaa4b82a574fec8a0bf26ad" title="Sets the weight of the projection specified by projection.">setWeight()</a>.  <a href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d8f/classLatticeTester_1_1WeightsUniform.html">WeightsUniform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies weights that are the same (usually 1) for all projections.  <a href="../../dd/d8f/classLatticeTester_1_1WeightsUniform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a951f7e7b03767aa0971dde55f9d328ec" id="r_a951f7e7b03767aa0971dde55f9d328ec"><td class="memItemLeft" align="right" valign="top"><a id="a951f7e7b03767aa0971dde55f9d328ec" name="a951f7e7b03767aa0971dde55f9d328ec"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>Weight</b></td></tr>
<tr class="memdesc:a951f7e7b03767aa0971dde55f9d328ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar weight type. <br /></td></tr>
<tr class="separator:a951f7e7b03767aa0971dde55f9d328ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9770e4d57aa715e249cd7e700c6f37e4" id="r_a9770e4d57aa715e249cd7e700c6f37e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> { <b>SUPNORM</b>
, <b>L1NORM</b>
, <b>L2NORM</b>
, <b>ZAREMBANORM</b>
 }</td></tr>
<tr class="memdesc:a9770e4d57aa715e249cd7e700c6f37e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The available norm types to measure the length of vectors.  <a href="#a9770e4d57aa715e249cd7e700c6f37e4">More...</a><br /></td></tr>
<tr class="separator:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f099c800f4c648134967a45b91058" id="r_ad78f099c800f4c648134967a45b91058"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78f099c800f4c648134967a45b91058">OutputType</a> { <b>TERM</b>
, <b>RES</b>
, <b>TEX</b>
, <b>GEN</b>
 }</td></tr>
<tr class="memdesc:ad78f099c800f4c648134967a45b91058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different choices of output formats.  <a href="#ad78f099c800f4c648134967a45b91058">More...</a><br /></td></tr>
<tr class="separator:ad78f099c800f4c648134967a45b91058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7b917d5ef7e8167bc50aa56109faff" id="r_aad7b917d5ef7e8167bc50aa56109faff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad7b917d5ef7e8167bc50aa56109faff">ProblemType</a> { <br />
&#160;&#160;<b>BASIS</b>
, <b>DUAL</b>
, <b>REDUCTION</b>
, <b>SHORTEST</b>
, <br />
&#160;&#160;<b>MERIT</b>
<br />
 }</td></tr>
<tr class="memdesc:aad7b917d5ef7e8167bc50aa56109faff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of problems that <a class="el" href="d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> can handle.  <a href="#aad7b917d5ef7e8167bc50aa56109faff">More...</a><br /></td></tr>
<tr class="separator:aad7b917d5ef7e8167bc50aa56109faff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f96ff406f8b56147a2b7fd96209cb2" id="r_a94f96ff406f8b56147a2b7fd96209cb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> { <b>DOUBLE</b>
, <b>QUADRUPLE</b>
, <b>XDOUBLE</b>
, <b>RR</b>
 }</td></tr>
<tr class="memdesc:a94f96ff406f8b56147a2b7fd96209cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This can be supersed by the Real type.  <a href="#a94f96ff406f8b56147a2b7fd96209cb2">More...</a><br /></td></tr>
<tr class="separator:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64954fb374b16e1fe991e435501d65" id="r_a9b64954fb374b16e1fe991e435501d65"><td class="memItemLeft" align="right" valign="top"><a id="a9b64954fb374b16e1fe991e435501d65" name="a9b64954fb374b16e1fe991e435501d65"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b64954fb374b16e1fe991e435501d65">PrimeType</a> { <b>PRIME</b>
, <b>PROB_PRIME</b>
, <b>COMPOSITE</b>
, <b>UNKNOWN</b>
 }</td></tr>
<tr class="memdesc:a9b64954fb374b16e1fe991e435501d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integer is prime, probably prime, composite or its status is unknown (or we do not care). <br /></td></tr>
<tr class="separator:a9b64954fb374b16e1fe991e435501d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3c4f4181718b7adc6f5e4513695a0" id="r_a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a> { <br />
&#160;&#160;<b>LENGTH</b>
, <b>SPECTRAL</b>
, <b>BEYER</b>
, <b>PALPHA</b>
, <br />
&#160;&#160;<b>BOUND_JS</b>
<br />
 }</td></tr>
<tr class="memdesc:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merit criteria to measure the quality of generators or lattices.  <a href="#a2cf3c4f4181718b7adc6f5e4513695a0">More...</a><br /></td></tr>
<tr class="separator:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab747c1cbb0f5e47fef711b62327a8e90" id="r_ab747c1cbb0f5e47fef711b62327a8e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> { <br />
&#160;&#160;<b>BESTLAT</b>
, <b>BESTUPBOUND</b>
, <b>LAMINATED</b>
, <b>ROGERS</b>
, <br />
&#160;&#160;<b>MINKL1</b>
, <b>MINKHLAW</b>
, <b>NONE</b>
<br />
 }</td></tr>
<tr class="memdesc:ab747c1cbb0f5e47fef711b62327a8e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different types of normalizations that can be used for shortest-vector lengths.  <a href="#ab747c1cbb0f5e47fef711b62327a8e90">More...</a><br /></td></tr>
<tr class="separator:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f9ab69a9d586b8273cbb29bb105fe" id="r_a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a> { <b>PAL</b>
, <b>NORMPAL</b>
, <b>BAL</b>
, <b>SEEKPAL</b>
 }</td></tr>
<tr class="memdesc:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of calculation is considered for the \(P_{\alpha}\) test.  <a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">More...</a><br /></td></tr>
<tr class="separator:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a213e64bd54d3e33a7aff0f80068cb" id="r_af2a213e64bd54d3e33a7aff0f80068cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">ReductionType</a> { <br />
&#160;&#160;<b>PAIR</b>
, <b>LLL</b>
, <b>BKZ</b>
, <b>BB</b>
, <br />
&#160;&#160;<b>PAIRBB</b>
, <b>LLLBB</b>
, <b>BKZBB</b>
<br />
 }</td></tr>
<tr class="memdesc:af2a213e64bd54d3e33a7aff0f80068cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all the possible lattice reductions implemented in <code><a class="el" href="d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a></code>.  <a href="#af2a213e64bd54d3e33a7aff0f80068cb">More...</a><br /></td></tr>
<tr class="separator:af2a213e64bd54d3e33a7aff0f80068cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf461b8f167cc8c7ebebc8ee6a96ee4" id="r_a5bf461b8f167cc8c7ebebc8ee6a96ee4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">DecompTypeBB</a> { <b>CHOLESKY</b>
, <b>TRIANGULAR</b>
 }</td></tr>
<tr class="memdesc:a5bf461b8f167cc8c7ebebc8ee6a96ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two possible ways of obtaining a triangular matrix to compute the bounds in the BB algorithm.  <a href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">More...</a><br /></td></tr>
<tr class="separator:a5bf461b8f167cc8c7ebebc8ee6a96ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff6c9ee29ca0bac6c63d2622508aa46" id="r_a1ff6c9ee29ca0bac6c63d2622508aa46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> { <b>LLLPROJ</b>
, <b>UPPERTRIPROJ</b>
 }</td></tr>
<tr class="memdesc:a1ff6c9ee29ca0bac6c63d2622508aa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two possible ways of computing the basis for a projection.  <a href="#a1ff6c9ee29ca0bac6c63d2622508aa46">More...</a><br /></td></tr>
<tr class="separator:a1ff6c9ee29ca0bac6c63d2622508aa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9e347d07097a1a3c82f1699ff93d58" id="r_a5e9e347d07097a1a3c82f1699ff93d58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">MeritType</a> { <b>MERITM</b>
, <b>MERITQ</b>
 }</td></tr>
<tr class="memdesc:a5e9e347d07097a1a3c82f1699ff93d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two different types of figures of merit.  <a href="#a5e9e347d07097a1a3c82f1699ff93d58">More...</a><br /></td></tr>
<tr class="separator:a5e9e347d07097a1a3c82f1699ff93d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa79e632b1a268bb144291dab079536ba" id="r_aa79e632b1a268bb144291dab079536ba"><td class="memItemLeft" align="right" valign="top"><a id="aa79e632b1a268bb144291dab079536ba" name="aa79e632b1a268bb144291dab079536ba"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa79e632b1a268bb144291dab079536ba"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LLLConstruction0</b> (NTL::Mat&lt; long &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:aa79e632b1a268bb144291dab079536ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f33d3b0de1f713f1ef2c1c595e84dd1" id="r_a3f33d3b0de1f713f1ef2c1c595e84dd1"><td class="memItemLeft" align="right" valign="top"><a id="a3f33d3b0de1f713f1ef2c1c595e84dd1" name="a3f33d3b0de1f713f1ef2c1c595e84dd1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3f33d3b0de1f713f1ef2c1c595e84dd1"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LLLConstruction0</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:a3f33d3b0de1f713f1ef2c1c595e84dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaf7b538955dfbb11fbb1847d33047a" id="r_adcaf7b538955dfbb11fbb1847d33047a"><td class="memItemLeft" align="right" valign="top"><a id="adcaf7b538955dfbb11fbb1847d33047a" name="adcaf7b538955dfbb11fbb1847d33047a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adcaf7b538955dfbb11fbb1847d33047a"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LLLConstruction0</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="separator:adcaf7b538955dfbb11fbb1847d33047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230dce0082ae9b33519142ff5ac095e1" id="r_a230dce0082ae9b33519142ff5ac095e1"><td class="memItemLeft" align="right" valign="top"><a id="a230dce0082ae9b33519142ff5ac095e1" name="a230dce0082ae9b33519142ff5ac095e1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a230dce0082ae9b33519142ff5ac095e1"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LLLConstruction0</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="separator:a230dce0082ae9b33519142ff5ac095e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943fc1de3c831c53f7c46fe7547e55f6" id="r_a943fc1de3c831c53f7c46fe7547e55f6"><td class="memItemLeft" align="right" valign="top"><a id="a943fc1de3c831c53f7c46fe7547e55f6" name="a943fc1de3c831c53f7c46fe7547e55f6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a943fc1de3c831c53f7c46fe7547e55f6"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LLLConstruction0</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="separator:a943fc1de3c831c53f7c46fe7547e55f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0375e124633660cc7ef0ba824d20401b" id="r_a0375e124633660cc7ef0ba824d20401b"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Real &gt; </td></tr>
<tr class="memitem:a0375e124633660cc7ef0ba824d20401b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0375e124633660cc7ef0ba824d20401b">LLLBasisConstruction</a> (IntMat &amp;gen, const Int &amp;m, double delta, long r, long c, RealVec *sqlen)</td></tr>
<tr class="memdesc:a0375e124633660cc7ef0ba824d20401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>LLLConstruction0</code>, except that this function adds implicitly the vectors \(m \mathbf{e}_i\) to the generating set, so it always returns a square matrix.  <br /></td></tr>
<tr class="separator:a0375e124633660cc7ef0ba824d20401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf38db6c503b603580edb998ab3dfb3a" id="r_adf38db6c503b603580edb998ab3dfb3a"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:adf38db6c503b603580edb998ab3dfb3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf38db6c503b603580edb998ab3dfb3a">lowerTriangularBasis</a> (IntMat &amp;basis, IntMat &amp;gen, const Int &amp;m, long dim1, long dim2)</td></tr>
<tr class="memdesc:adf38db6c503b603580edb998ab3dfb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <code>gen</code> and iteratively transforms it into a lower triangular lattice basis into the matrix <code>basis</code>.  <br /></td></tr>
<tr class="separator:adf38db6c503b603580edb998ab3dfb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0699288204d864638ec9cc3461192bc" id="r_ac0699288204d864638ec9cc3461192bc"><td class="memTemplParams" colspan="2"><a id="ac0699288204d864638ec9cc3461192bc" name="ac0699288204d864638ec9cc3461192bc"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ac0699288204d864638ec9cc3461192bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upperTriangularBasis</b> (IntMat &amp;basis, IntMat &amp;gen, const Int &amp;m, long dim1, long dim2)</td></tr>
<tr class="memdesc:ac0699288204d864638ec9cc3461192bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>lowerTriangularBasis</code>, except that the returned basis is upper triangular. <br /></td></tr>
<tr class="separator:ac0699288204d864638ec9cc3461192bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4b386e05b14e28a1a77e18af32acce" id="r_a3d4b386e05b14e28a1a77e18af32acce"><td class="memTemplParams" colspan="2"><a id="a3d4b386e05b14e28a1a77e18af32acce" name="a3d4b386e05b14e28a1a77e18af32acce"></a>
template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a3d4b386e05b14e28a1a77e18af32acce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upperTriangularBasisOld96</b> (Matr &amp;V, Matr &amp;W, const Int &amp;m, int64_t lin, int64_t col)</td></tr>
<tr class="separator:a3d4b386e05b14e28a1a77e18af32acce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7599453daee81235947f198aa0fdabd2" id="r_a7599453daee81235947f198aa0fdabd2"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a7599453daee81235947f198aa0fdabd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7599453daee81235947f198aa0fdabd2">mDualLowerTriangular</a> (IntMat &amp;B, const IntMat &amp;A, const Int &amp;m, long dim)</td></tr>
<tr class="memdesc:a7599453daee81235947f198aa0fdabd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a lower-triangular basis matrix <code>basis</code> and computes the m-dual basis <code>basisDual</code>.  <br /></td></tr>
<tr class="separator:a7599453daee81235947f198aa0fdabd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879bb70764843a663c4a22e993cd1d8b" id="r_a879bb70764843a663c4a22e993cd1d8b"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a879bb70764843a663c4a22e993cd1d8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a879bb70764843a663c4a22e993cd1d8b">mDualUpperTriangular</a> (IntMat &amp;B, const IntMat &amp;A, const Int &amp;m, long dim)</td></tr>
<tr class="memdesc:a879bb70764843a663c4a22e993cd1d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a upper triangular basis matrix <code>basis</code> and computes the m-dual basis <code>basisDual</code>.  <br /></td></tr>
<tr class="separator:a879bb70764843a663c4a22e993cd1d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330c8d1822bd62d27f7708e04e409a96" id="r_a330c8d1822bd62d27f7708e04e409a96"><td class="memTemplParams" colspan="2"><a id="a330c8d1822bd62d27f7708e04e409a96" name="a330c8d1822bd62d27f7708e04e409a96"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a330c8d1822bd62d27f7708e04e409a96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mDualLowerTriangularMod0</b> (IntMat &amp;B, const IntMat &amp;A, const Int &amp;m, long dim)</td></tr>
<tr class="memdesc:a330c8d1822bd62d27f7708e04e409a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>mDualLowerTriangular</code> and then reduces all the non-diagonal <code>mod m</code> towards 0. <br /></td></tr>
<tr class="separator:a330c8d1822bd62d27f7708e04e409a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541c52e31adea978279ddd93a5cbdc18" id="r_a541c52e31adea978279ddd93a5cbdc18"><td class="memTemplParams" colspan="2"><a id="a541c52e31adea978279ddd93a5cbdc18" name="a541c52e31adea978279ddd93a5cbdc18"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a541c52e31adea978279ddd93a5cbdc18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mDualUpperTriangularMod0</b> (IntMat &amp;B, const IntMat &amp;A, const Int &amp;m, long dim)</td></tr>
<tr class="memdesc:a541c52e31adea978279ddd93a5cbdc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>mDualUpperTriangular</code> and then reduces all the non-diagonal <code>mod m</code> towards 0. <br /></td></tr>
<tr class="separator:a541c52e31adea978279ddd93a5cbdc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938bceedde41f1318302ed9037dc0f83" id="r_a938bceedde41f1318302ed9037dc0f83"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a938bceedde41f1318302ed9037dc0f83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a938bceedde41f1318302ed9037dc0f83">mDualUpperTriangularOld96</a> (IntMat &amp;basisDual, const IntMat &amp;basis, const Int &amp;m, long dim)</td></tr>
<tr class="memdesc:a938bceedde41f1318302ed9037dc0f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does essentially the same thing as <code>mDualUpperTriangular</code>, but the algorithm is slightly different.  <br /></td></tr>
<tr class="separator:a938bceedde41f1318302ed9037dc0f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdb586351ffc042ae953045a73f01fb" id="r_a2cdb586351ffc042ae953045a73f01fb"><td class="memItemLeft" align="right" valign="top"><a id="a2cdb586351ffc042ae953045a73f01fb" name="a2cdb586351ffc042ae953045a73f01fb"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2cdb586351ffc042ae953045a73f01fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mDualUpperTriangularOld96</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basisDual, const NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, const NTL::ZZ &amp;m, long dim)</td></tr>
<tr class="separator:a2cdb586351ffc042ae953045a73f01fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b517f6075fece22fd4336115e2fd524" id="r_a8b517f6075fece22fd4336115e2fd524"><td class="memTemplParams" colspan="2"><a id="a8b517f6075fece22fd4336115e2fd524" name="a8b517f6075fece22fd4336115e2fd524"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a8b517f6075fece22fd4336115e2fd524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mDualBasis</b> (NTL::Mat&lt; Int &gt; &amp;basisDual, const NTL::Mat&lt; Int &gt; &amp;basis, const Int &amp;m)</td></tr>
<tr class="separator:a8b517f6075fece22fd4336115e2fd524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452ed7260c613b06e3ccd84682b989a2" id="r_a452ed7260c613b06e3ccd84682b989a2"><td class="memItemLeft" align="right" valign="top"><a id="a452ed7260c613b06e3ccd84682b989a2" name="a452ed7260c613b06e3ccd84682b989a2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a452ed7260c613b06e3ccd84682b989a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mDualBasis</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basisDual, const NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, const NTL::ZZ &amp;m)</td></tr>
<tr class="separator:a452ed7260c613b06e3ccd84682b989a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6373857de656ccfeb0972950b2986d" id="r_aac6373857de656ccfeb0972950b2986d"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aac6373857de656ccfeb0972950b2986d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac6373857de656ccfeb0972950b2986d">projectMatrix</a> (IntMat &amp;out, const IntMat &amp;in, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, long r)</td></tr>
<tr class="memdesc:aac6373857de656ccfeb0972950b2986d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function overwrites the first <code>r</code> rows of matrix 'out' by a matrix formed by the first <code>r</code> rows of the c columns of matrix <code>in</code> that are specified by <code>proj</code>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <code>proj</code>.  <br /></td></tr>
<tr class="separator:aac6373857de656ccfeb0972950b2986d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e21410fcd60b6dc1a9bf1ac58ad029" id="r_a33e21410fcd60b6dc1a9bf1ac58ad029"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Real &gt; </td></tr>
<tr class="memitem:a33e21410fcd60b6dc1a9bf1ac58ad029"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33e21410fcd60b6dc1a9bf1ac58ad029">projectionConstructionLLL</a> (IntMat &amp;projBasis, const IntMat &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, const double delta, long r, RealVec *sqlen)</td></tr>
<tr class="memdesc:a33e21410fcd60b6dc1a9bf1ac58ad029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a basis for the projection <code>proj</code> of the lattice with basis <code>inBasis</code>, using <code>LLLBasisConstruction</code>, and returns it in <code>projBasis</code>.  <br /></td></tr>
<tr class="separator:a33e21410fcd60b6dc1a9bf1ac58ad029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab54fa69b7e88d66cbcc2f7568674ac" id="r_afab54fa69b7e88d66cbcc2f7568674ac"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:afab54fa69b7e88d66cbcc2f7568674ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afab54fa69b7e88d66cbcc2f7568674ac">projectionConstructionUpperTri</a> (IntMat &amp;projBasis, const IntMat &amp;inBasis, IntMat &amp;genTemp, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, long r)</td></tr>
<tr class="memdesc:afab54fa69b7e88d66cbcc2f7568674ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>projectionConstructionLLL</code>, but the construction is made using <code>upperTriangularBasis</code>, so the returned basis is upper triangular.  <br /></td></tr>
<tr class="separator:afab54fa69b7e88d66cbcc2f7568674ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55ee07787a3411bde9ae8ae7dd18801" id="r_ad55ee07787a3411bde9ae8ae7dd18801"><td class="memTemplParams" colspan="2"><a id="ad55ee07787a3411bde9ae8ae7dd18801" name="ad55ee07787a3411bde9ae8ae7dd18801"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ad55ee07787a3411bde9ae8ae7dd18801"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>projectionConstructionUpperTri</b> (IntMat &amp;projBasis, const IntMat &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, long r)</td></tr>
<tr class="separator:ad55ee07787a3411bde9ae8ae7dd18801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaaa449af42b672227ce6606347a066" id="r_aacaaa449af42b672227ce6606347a066"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aacaaa449af42b672227ce6606347a066"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacaaa449af42b672227ce6606347a066">projectionConstruction</a> (IntMat &amp;projBasis, const IntMat &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> projType, const double delta)</td></tr>
<tr class="memdesc:aacaaa449af42b672227ce6606347a066"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this version, the construction method is passed as a parameter.  <br /></td></tr>
<tr class="separator:aacaaa449af42b672227ce6606347a066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71110e4d0e1c979d7f5da2593e8edddb" id="r_a71110e4d0e1c979d7f5da2593e8edddb"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71110e4d0e1c979d7f5da2593e8edddb">lFactorial</a> (int64_t t)</td></tr>
<tr class="memdesc:a71110e4d0e1c979d7f5da2593e8edddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\).  <br /></td></tr>
<tr class="separator:a71110e4d0e1c979d7f5da2593e8edddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c94b54767104cea58e0f1b6c0d11e" id="r_a886c94b54767104cea58e0f1b6c0d11e"><td class="memItemLeft" align="right" valign="top"><a id="a886c94b54767104cea58e0f1b6c0d11e" name="a886c94b54767104cea58e0f1b6c0d11e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Digamma</b> (double x)</td></tr>
<tr class="memdesc:a886c94b54767104cea58e0f1b6c0d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\). <br /></td></tr>
<tr class="separator:a886c94b54767104cea58e0f1b6c0d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67515c2643b5f7029486e8118ede05d6" id="r_a67515c2643b5f7029486e8118ede05d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67515c2643b5f7029486e8118ede05d6">BernoulliPoly</a> (int64_t n, double x)</td></tr>
<tr class="memdesc:a67515c2643b5f7029486e8118ede05d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\).  <br /></td></tr>
<tr class="separator:a67515c2643b5f7029486e8118ede05d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4b5013c295f9f07b9b2d8f26ee5f4" id="r_a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memItemLeft" align="right" valign="top"><a id="a61a4b5013c295f9f07b9b2d8f26ee5f4" name="a61a4b5013c295f9f07b9b2d8f26ee5f4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Harmonic</b> (std::int64_t n)</td></tr>
<tr class="memdesc:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(n\)-th harmonic number \(H_n  = \sum_{j=1}^n 1/j\). <br /></td></tr>
<tr class="separator:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aefa49a034495dcc46721c275f329b0" id="r_a3aefa49a034495dcc46721c275f329b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aefa49a034495dcc46721c275f329b0">Harmonic2</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a3aefa49a034495dcc46721c275f329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum.  <br /></td></tr>
<tr class="separator:a3aefa49a034495dcc46721c275f329b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb56e7569fb24800973df89d757f2fd" id="r_a0bb56e7569fb24800973df89d757f2fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bb56e7569fb24800973df89d757f2fd">FourierC1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:a0bb56e7569fb24800973df89d757f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series (see <b>[vJOE92b]</b>)  <br /></td></tr>
<tr class="separator:a0bb56e7569fb24800973df89d757f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f708fa0e8d6aa53427b3e8927f5504" id="r_ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5f708fa0e8d6aa53427b3e8927f5504">FourierE1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series.  <br /></td></tr>
<tr class="separator:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dafe7fe191c17bcb7c178149db6570" id="r_a63dafe7fe191c17bcb7c178149db6570"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Real &gt; </td></tr>
<tr class="memitem:a63dafe7fe191c17bcb7c178149db6570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63dafe7fe191c17bcb7c178149db6570">redLLL</a> (IntMat &amp;basis, double delta, long dim, RealVec *sqlen)</td></tr>
<tr class="memdesc:a63dafe7fe191c17bcb7c178149db6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation of the LLL reduction algorithm with factor <code>delta</code>, presented in <b>[mSCH91a]</b> (see also <b>[iLEC22l]</b>).  <br /></td></tr>
<tr class="separator:a63dafe7fe191c17bcb7c178149db6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba0cc62c4a1f60207e43f96b0b8b505" id="r_a7ba0cc62c4a1f60207e43f96b0b8b505"><td class="memItemLeft" align="right" valign="top"><a id="a7ba0cc62c4a1f60207e43f96b0b8b505" name="a7ba0cc62c4a1f60207e43f96b0b8b505"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7ba0cc62c4a1f60207e43f96b0b8b505"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redLLL</b> (NTL::Mat&lt; int64_t &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:a7ba0cc62c4a1f60207e43f96b0b8b505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c311ceec469a24bb840ad475087f47" id="r_a17c311ceec469a24bb840ad475087f47"><td class="memItemLeft" align="right" valign="top"><a id="a17c311ceec469a24bb840ad475087f47" name="a17c311ceec469a24bb840ad475087f47"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a17c311ceec469a24bb840ad475087f47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redLLL</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:a17c311ceec469a24bb840ad475087f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67de711b50856965f26fac46cb92a37" id="r_ae67de711b50856965f26fac46cb92a37"><td class="memItemLeft" align="right" valign="top"><a id="ae67de711b50856965f26fac46cb92a37" name="ae67de711b50856965f26fac46cb92a37"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae67de711b50856965f26fac46cb92a37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redLLL</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="separator:ae67de711b50856965f26fac46cb92a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9970c52ca29fba32363dbc13d4731dd2" id="r_a9970c52ca29fba32363dbc13d4731dd2"><td class="memItemLeft" align="right" valign="top"><a id="a9970c52ca29fba32363dbc13d4731dd2" name="a9970c52ca29fba32363dbc13d4731dd2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9970c52ca29fba32363dbc13d4731dd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redLLL</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="separator:a9970c52ca29fba32363dbc13d4731dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06b7a4878550ec92b3138a5c121e4a5" id="r_ac06b7a4878550ec92b3138a5c121e4a5"><td class="memItemLeft" align="right" valign="top"><a id="ac06b7a4878550ec92b3138a5c121e4a5" name="ac06b7a4878550ec92b3138a5c121e4a5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac06b7a4878550ec92b3138a5c121e4a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redLLL</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="separator:ac06b7a4878550ec92b3138a5c121e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5830bb0fae462b5e85c8eeb1c126a647" id="r_a5830bb0fae462b5e85c8eeb1c126a647"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a5830bb0fae462b5e85c8eeb1c126a647"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5830bb0fae462b5e85c8eeb1c126a647">redLLLExact</a> (IntMat &amp;basis, double delta)</td></tr>
<tr class="memdesc:a5830bb0fae462b5e85c8eeb1c126a647"><td class="mdescLeft">&#160;</td><td class="mdescRight">This static function implements an exact algorithm from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> to perform the original LLL reduction.  <br /></td></tr>
<tr class="separator:a5830bb0fae462b5e85c8eeb1c126a647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd6a9c79f1e8d406981e707235b99e6" id="r_aebd6a9c79f1e8d406981e707235b99e6"><td class="memItemLeft" align="right" valign="top"><a id="aebd6a9c79f1e8d406981e707235b99e6" name="aebd6a9c79f1e8d406981e707235b99e6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aebd6a9c79f1e8d406981e707235b99e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redLLLExact</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta)</td></tr>
<tr class="separator:aebd6a9c79f1e8d406981e707235b99e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b3c8b73699d62e791da7d1bfb848db" id="r_af5b3c8b73699d62e791da7d1bfb848db"><td class="memTemplParams" colspan="2"><a id="af5b3c8b73699d62e791da7d1bfb848db" name="af5b3c8b73699d62e791da7d1bfb848db"></a>
template&lt;typename Int , typename Real &gt; </td></tr>
<tr class="memitem:af5b3c8b73699d62e791da7d1bfb848db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redBKZ</b> (IntMat &amp;basis, double delta, long blocksize, long prune, long dim, RealVec *sqlen)</td></tr>
<tr class="separator:af5b3c8b73699d62e791da7d1bfb848db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3156e70f2ab3dad98a95ae19142ac9b0" id="r_a3156e70f2ab3dad98a95ae19142ac9b0"><td class="memItemLeft" align="right" valign="top"><a id="a3156e70f2ab3dad98a95ae19142ac9b0" name="a3156e70f2ab3dad98a95ae19142ac9b0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3156e70f2ab3dad98a95ae19142ac9b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redBKZ</b> (NTL::Mat&lt; int64_t &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:a3156e70f2ab3dad98a95ae19142ac9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd397a850f675b73135e0267f2097dd" id="r_abdd397a850f675b73135e0267f2097dd"><td class="memItemLeft" align="right" valign="top"><a id="abdd397a850f675b73135e0267f2097dd" name="abdd397a850f675b73135e0267f2097dd"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abdd397a850f675b73135e0267f2097dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redBKZ</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:abdd397a850f675b73135e0267f2097dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac0875e1a96e8d73119a2ab60522727" id="r_afac0875e1a96e8d73119a2ab60522727"><td class="memItemLeft" align="right" valign="top"><a id="afac0875e1a96e8d73119a2ab60522727" name="afac0875e1a96e8d73119a2ab60522727"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afac0875e1a96e8d73119a2ab60522727"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redBKZ</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="separator:afac0875e1a96e8d73119a2ab60522727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a3ac4d76bc194019f487522ab52947" id="r_a06a3ac4d76bc194019f487522ab52947"><td class="memItemLeft" align="right" valign="top"><a id="a06a3ac4d76bc194019f487522ab52947" name="a06a3ac4d76bc194019f487522ab52947"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a06a3ac4d76bc194019f487522ab52947"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redBKZ</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="separator:a06a3ac4d76bc194019f487522ab52947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25595dce14a5f583031ea455884105c" id="r_ab25595dce14a5f583031ea455884105c"><td class="memItemLeft" align="right" valign="top"><a id="ab25595dce14a5f583031ea455884105c" name="ab25595dce14a5f583031ea455884105c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab25595dce14a5f583031ea455884105c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>redBKZ</b> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="separator:ab25595dce14a5f583031ea455884105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932" id="r_ad4d16fed8fda92252dc423db28136932"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4d16fed8fda92252dc423db28136932">swap9</a> (T &amp;x, T &amp;y)</td></tr>
<tr class="memdesc:ad4d16fed8fda92252dc423db28136932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes references to two variables of a generic type and swaps their content.  <br /></td></tr>
<tr class="separator:ad4d16fed8fda92252dc423db28136932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1b2821c4805119b5eb02b3fe0437eb" id="r_aab1b2821c4805119b5eb02b3fe0437eb"><td class="memTemplParams" colspan="2"><a id="aab1b2821c4805119b5eb02b3fe0437eb" name="aab1b2821c4805119b5eb02b3fe0437eb"></a>
template&lt;typename Matr1 , typename Matr2 &gt; </td></tr>
<tr class="memitem:aab1b2821c4805119b5eb02b3fe0437eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copyMatrixToMat</b> (Matr1 &amp;A, Matr2 &amp;B)</td></tr>
<tr class="separator:aab1b2821c4805119b5eb02b3fe0437eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b6fca0fb17656efed5391c452afc9b" id="r_a06b6fca0fb17656efed5391c452afc9b"><td class="memTemplParams" colspan="2"><a id="a06b6fca0fb17656efed5391c452afc9b" name="a06b6fca0fb17656efed5391c452afc9b"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a06b6fca0fb17656efed5391c452afc9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>printBase</b> (IntMat bas_mat)</td></tr>
<tr class="separator:a06b6fca0fb17656efed5391c452afc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee961bb86089ad2cb9df512b1164e2f" id="r_aaee961bb86089ad2cb9df512b1164e2f"><td class="memTemplParams" colspan="2"><a id="aaee961bb86089ad2cb9df512b1164e2f" name="aaee961bb86089ad2cb9df512b1164e2f"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aaee961bb86089ad2cb9df512b1164e2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>printBase2</b> (IntMat bas_mat)</td></tr>
<tr class="separator:aaee961bb86089ad2cb9df512b1164e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8df54cbab1b05dae27118a586c3d4c4" id="r_ab8df54cbab1b05dae27118a586c3d4c4"><td class="memTemplParams" colspan="2"><a id="ab8df54cbab1b05dae27118a586c3d4c4" name="ab8df54cbab1b05dae27118a586c3d4c4"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ab8df54cbab1b05dae27118a586c3d4c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (IntMat &amp;b1, IntMat &amp;b2)</td></tr>
<tr class="separator:ab8df54cbab1b05dae27118a586c3d4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1f7ecf7379c91d2d97bc70f20d5e24" id="r_a6d1f7ecf7379c91d2d97bc70f20d5e24"><td class="memTemplParams" colspan="2"><a id="a6d1f7ecf7379c91d2d97bc70f20d5e24" name="a6d1f7ecf7379c91d2d97bc70f20d5e24"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a6d1f7ecf7379c91d2d97bc70f20d5e24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (IntMat &amp;b1, IntMat &amp;b2, int64_t r, int64_t c)</td></tr>
<tr class="separator:a6d1f7ecf7379c91d2d97bc70f20d5e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3637aa8820727e70ae7e915f3cde53" id="r_a1b3637aa8820727e70ae7e915f3cde53"><td class="memItemLeft" align="right" valign="top"><a id="a1b3637aa8820727e70ae7e915f3cde53" name="a1b3637aa8820727e70ae7e915f3cde53"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>getWidth</b> (clock_t time[], int64_t dim, std::string message, clock_t totals[], int64_t ind)</td></tr>
<tr class="separator:a1b3637aa8820727e70ae7e915f3cde53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246df9b0832e4c4fc450c83aa5e171ab" id="r_a246df9b0832e4c4fc450c83aa5e171ab"><td class="memItemLeft" align="right" valign="top"><a id="a246df9b0832e4c4fc450c83aa5e171ab" name="a246df9b0832e4c4fc450c83aa5e171ab"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="memdesc:a246df9b0832e4c4fc450c83aa5e171ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats the coordinate set <code>coords</code> and outputs it to <code>os</code>. <br /></td></tr>
<tr class="separator:a246df9b0832e4c4fc450c83aa5e171ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71356dcc070f0bc5a4ed43864bd9971" id="r_ac71356dcc070f0bc5a4ed43864bd9971"><td class="memItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#ac71356dcc070f0bc5a4ed43864bd9971">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="memdesc:ac71356dcc070f0bc5a4ed43864bd9971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a formatted coordinate set from <code>is</code>.  <br /></td></tr>
<tr class="separator:ac71356dcc070f0bc5a4ed43864bd9971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c12eea0f3df2908bb03fb2675add3" id="r_aef6c12eea0f3df2908bb03fb2675add3"><td class="memItemLeft" align="right" valign="top"><a id="aef6c12eea0f3df2908bb03fb2675add3" name="aef6c12eea0f3df2908bb03fb2675add3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a> &amp;o)</td></tr>
<tr class="memdesc:aef6c12eea0f3df2908bb03fb2675add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the type of weights, formats them and outputs them on <code>os</code>. <br /></td></tr>
<tr class="separator:aef6c12eea0f3df2908bb03fb2675add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e872b69d81b7fd8a3abd47aaa29006" id="r_a85e872b69d81b7fd8a3abd47aaa29006"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html#a85e872b69d81b7fd8a3abd47aaa29006">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html">WeightsProjectionDependent</a> &amp;weights)</td></tr>
<tr class="memdesc:a85e872b69d81b7fd8a3abd47aaa29006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads formatted projection-dependent weights into the object <code>weights</code>.  <br /></td></tr>
<tr class="separator:a85e872b69d81b7fd8a3abd47aaa29006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random numbers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All the functions of this module use LFSR258 as an underlying source for pseudo-random numbers.</p>
<p>A free (as in freedom) implementation of this generator can be found at <a href="http://simul.iro.umontreal.ca/">http://simul.iro.umontreal.ca/</a> as well as the article presenting it. All the functions generating some sort of random number will advance an integer version of LFSR258 by one state and output a transformation of the state to give a double, an int64_t or bits. </p>
</div></td></tr>
<tr class="memitem:abba336d3a5abb22b8367ddfa37a713e4" id="r_abba336d3a5abb22b8367ddfa37a713e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abba336d3a5abb22b8367ddfa37a713e4">RandU01</a> ()</td></tr>
<tr class="memdesc:abba336d3a5abb22b8367ddfa37a713e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number in \([0, 1)\).  <br /></td></tr>
<tr class="separator:abba336d3a5abb22b8367ddfa37a713e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7dd0225a074e885d6d54916757fcec" id="r_a3f7dd0225a074e885d6d54916757fcec"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f7dd0225a074e885d6d54916757fcec">RandInt</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:a3f7dd0225a074e885d6d54916757fcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uniform pseudo-random integer in \([i, j]\).  <br /></td></tr>
<tr class="separator:a3f7dd0225a074e885d6d54916757fcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdad6592203c9b83f2ef7caf7b8441f" id="r_a3fdad6592203c9b83f2ef7caf7b8441f"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fdad6592203c9b83f2ef7caf7b8441f">RandBits</a> (int64_t s)</td></tr>
<tr class="memdesc:a3fdad6592203c9b83f2ef7caf7b8441f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer.  <br /></td></tr>
<tr class="separator:a3fdad6592203c9b83f2ef7caf7b8441f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68bc6b1e81a03d09ea07fa9efed658" id="r_a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a68bc6b1e81a03d09ea07fa9efed658">SetSeed</a> (std::uint64_t seed)</td></tr>
<tr class="memdesc:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed of the generator.  <br /></td></tr>
<tr class="separator:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are complete reimplementation of certain mathematical functions, or wrappers for standard C/C++ functions. </p>
</div></td></tr>
<tr class="memitem:a9abb8da9fdc5fa2c37d44165f8660aaf" id="r_a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memItemLeft" align="right" valign="top"><a id="a9abb8da9fdc5fa2c37d44165f8660aaf" name="a9abb8da9fdc5fa2c37d44165f8660aaf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mysqrt</b> (double x)</td></tr>
<tr class="memdesc:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\). <br /></td></tr>
<tr class="separator:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b" id="r_ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplParams" colspan="2"><a id="ae12db9335c229d7c60e570dab50ef05b" name="ae12db9335c229d7c60e570dab50ef05b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Lg</b> (const T &amp;x)</td></tr>
<tr class="memdesc:ae12db9335c229d7c60e570dab50ef05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2. <br /></td></tr>
<tr class="separator:ae12db9335c229d7c60e570dab50ef05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4b6c931cf0a19642828796b3b3bef" id="r_a12e4b6c931cf0a19642828796b3b3bef"><td class="memItemLeft" align="right" valign="top"><a id="a12e4b6c931cf0a19642828796b3b3bef" name="a12e4b6c931cf0a19642828796b3b3bef"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Lg</b> (std::int64_t x)</td></tr>
<tr class="memdesc:a12e4b6c931cf0a19642828796b3b3bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2. <br /></td></tr>
<tr class="separator:a12e4b6c931cf0a19642828796b3b3bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed" id="r_a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplParams" colspan="2"><a id="a67e0668a966fb5fa3e22fc1ffa6d59ed" name="a67e0668a966fb5fa3e22fc1ffa6d59ed"></a>
template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplItemLeft" align="right" valign="top">Scal&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (Scal x)</td></tr>
<tr class="memdesc:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of \(x\). <br /></td></tr>
<tr class="separator:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c" id="r_a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59016f13e4470ad17683b1cfeb70153c">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a59016f13e4470ad17683b1cfeb70153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of <code>x</code>.  <br /></td></tr>
<tr class="separator:a59016f13e4470ad17683b1cfeb70153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d" id="r_a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15f15a1453b578cb49b2e3deda5a200d">Round</a> (Real x)</td></tr>
<tr class="memdesc:a15f15a1453b578cb49b2e3deda5a200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of x rounded to the NEAREST integer value.  <br /></td></tr>
<tr class="separator:a15f15a1453b578cb49b2e3deda5a200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941ee9c334c67adb02d4d7098fa22553" id="r_a941ee9c334c67adb02d4d7098fa22553"><td class="memItemLeft" align="right" valign="top"><a id="a941ee9c334c67adb02d4d7098fa22553" name="a941ee9c334c67adb02d4d7098fa22553"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>Factorial</b> (int64_t t)</td></tr>
<tr class="memdesc:a941ee9c334c67adb02d4d7098fa22553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\) and returns it as an std::int64_t. <br /></td></tr>
<tr class="separator:a941ee9c334c67adb02d4d7098fa22553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Division and modular arithmetic</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Pour certaines fonctions, les résultats sont mis dans les premiers arguments de la fonction pour être compatible avec <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>; pour d’autres, ils sont mis dans les derniers arguments pour être compatible avec notre ancienne version de <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> en Modula-2. Plutôt détestable. Je crois qu’il faudra un jour réarranger les arguments des fonctions pour qu’elles suivent toutes la même convention que <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>.</dd></dl>
<p>This module offers function to perform division and find remainders in a standard way. These functions are usefull in the case where one wants to do divisions or find remainders of operations with negative operands. The reason is that <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> and primitive types do not use the same logic when doing calculations on negative numbers.</p>
<p>Basically, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> will always floor a division and C++ will always truncate a division (which effectively means the floor function is replaced by a roof function if the answer is a negative number). When calculating the remainder of x/y, both apply the same logic but get a different result because they do not do the same division. In both representations, we have that   </p><p class="formulaDsp">
\[
   y\cdot(x/y) + x%y = x.
\]
</p>
<p> It turns out that, with negative values, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> will return an integer with the same sign as y where C++ will return an integer of opposite sign (but both will return the same number modulo y). </p>
</div></td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f" id="r_aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9056e4da6e74d83c6061650caf9e59f">Quotient</a> (const Int &amp;a, const Int &amp;b, Int &amp;q)</td></tr>
<tr class="memdesc:aa9056e4da6e74d83c6061650caf9e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>a/b</code>, truncates the fractional part and puts the result in q.  <br /></td></tr>
<tr class="separator:aa9056e4da6e74d83c6061650caf9e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327" id="r_a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33b2ac0aaf5689dbf1f2225dbf14b327">Modulo</a> (const Real &amp;a, const Real &amp;b, Real &amp;r)</td></tr>
<tr class="memdesc:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of a/b and stores its positive equivalent mod b in r.  <br /></td></tr>
<tr class="separator:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace733f06613d555cb7c6fb617e8a33b7" id="r_ace733f06613d555cb7c6fb617e8a33b7"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ace733f06613d555cb7c6fb617e8a33b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace733f06613d555cb7c6fb617e8a33b7">ModuloTowardZero</a> (const Int &amp;a, const Int &amp;b, Int &amp;r)</td></tr>
<tr class="memdesc:ace733f06613d555cb7c6fb617e8a33b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the element <code>r = a mod b</code> that is closest to 0.  <br /></td></tr>
<tr class="separator:ace733f06613d555cb7c6fb617e8a33b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d24a696d90d81de9128f9af7c6694d5" id="r_a3d24a696d90d81de9128f9af7c6694d5"><td class="memItemLeft" align="right" valign="top"><a id="a3d24a696d90d81de9128f9af7c6694d5" name="a3d24a696d90d81de9128f9af7c6694d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ModuloTowardZero</b> (const std::int64_t &amp;a, const std::int64_t &amp;b, std::int64_t &amp;r)</td></tr>
<tr class="separator:a3d24a696d90d81de9128f9af7c6694d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570" id="r_aeccbd231b4002cadbaac0157871f5570"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeccbd231b4002cadbaac0157871f5570">Divide</a> (Real &amp;q, Real &amp;r, const Real &amp;a, const Real &amp;b)</td></tr>
<tr class="memdesc:aeccbd231b4002cadbaac0157871f5570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder  \(r = a
\bmod b\).  <br /></td></tr>
<tr class="separator:aeccbd231b4002cadbaac0157871f5570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772" id="r_a76b74332cd4ded85d51dc6020b930772"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76b74332cd4ded85d51dc6020b930772">DivideRound</a> (const Real &amp;a, const Real &amp;b, Real &amp;q)</td></tr>
<tr class="memdesc:a76b74332cd4ded85d51dc6020b930772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\).  <br /></td></tr>
<tr class="separator:a76b74332cd4ded85d51dc6020b930772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db19d396c104b730dd5ea23a7752b5" id="r_a14db19d396c104b730dd5ea23a7752b5"><td class="memItemLeft" align="right" valign="top"><a id="a14db19d396c104b730dd5ea23a7752b5" name="a14db19d396c104b730dd5ea23a7752b5"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>gcd</b> (std::int64_t a, std::int64_t b)</td></tr>
<tr class="memdesc:a14db19d396c104b730dd5ea23a7752b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the greatest common divisor of \(a\) and \(b\) by using Stein's binary GCD algorithm. <br /></td></tr>
<tr class="separator:a14db19d396c104b730dd5ea23a7752b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d" id="r_abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide</a> (const Int &amp;A, const Int &amp;B, Int &amp;C, Int &amp;D, Int &amp;E, Int &amp;F, Int &amp;G)</td></tr>
<tr class="memdesc:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the greater common divisor of <code>A</code> and <code>B</code> with Euclid's algorithm.  <br /></td></tr>
<tr class="separator:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734b88021d0f2b51a6c8ab5ca7c1a5aa" id="r_a734b88021d0f2b51a6c8ab5ca7c1a5aa"><td class="memTemplParams" colspan="2"><a id="a734b88021d0f2b51a6c8ab5ca7c1a5aa" name="a734b88021d0f2b51a6c8ab5ca7c1a5aa"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a734b88021d0f2b51a6c8ab5ca7c1a5aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Euclide</b> (const Int &amp;A, const Int &amp;B, Int &amp;C, Int &amp;D, Int &amp;G)</td></tr>
<tr class="separator:a734b88021d0f2b51a6c8ab5ca7c1a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2f58453cd5cd239b67d0eb92b3dadf" id="r_aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa2f58453cd5cd239b67d0eb92b3dadf">TransposeMatrix</a> (IntMat &amp;mat, IntMat &amp;mat2)</td></tr>
<tr class="memdesc:aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <code>mat</code> and iteratively transforms it into an upper triangular lattice basis into the matrix <code>mat2</code>.  <br /></td></tr>
<tr class="separator:aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are utilities to manipulate vectors ranging from instantiation to scalar product.</p>
<p>******** MOST OF THIS CAN BE REMOVED. WE CAN JUST USE <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> DIRECTLY. ********* </p>
</div></td></tr>
<tr class="memitem:a0416b061a693a6e604d4cc99b14a7050" id="r_a0416b061a693a6e604d4cc99b14a7050"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0416b061a693a6e604d4cc99b14a7050"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0416b061a693a6e604d4cc99b14a7050">CreateVect</a> (Real *&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a0416b061a693a6e604d4cc99b14a7050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to <code>A</code> as an array of <code>Real</code> of dimension <code>d</code> and initializes its elements to 0.  <br /></td></tr>
<tr class="separator:a0416b061a693a6e604d4cc99b14a7050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40f02397dea42344f2c4b6016f5e4f0" id="r_af40f02397dea42344f2c4b6016f5e4f0"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:af40f02397dea42344f2c4b6016f5e4f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af40f02397dea42344f2c4b6016f5e4f0">CreateVect</a> (Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:af40f02397dea42344f2c4b6016f5e4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector <code>A</code> of dimensions <code>d+1</code> and initializes its elements to 0.  <br /></td></tr>
<tr class="separator:af40f02397dea42344f2c4b6016f5e4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3" id="r_a3290d1c59f58412753021d37fd9059c3"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3290d1c59f58412753021d37fd9059c3">DeleteVect</a> (Real *&amp;A)</td></tr>
<tr class="memdesc:a3290d1c59f58412753021d37fd9059c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <code>A</code>.  <br /></td></tr>
<tr class="separator:a3290d1c59f58412753021d37fd9059c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898" id="r_a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74b9ac2e545b1a8e3febffe458488898">DeleteVect</a> (Vect &amp;A)</td></tr>
<tr class="memdesc:a74b9ac2e545b1a8e3febffe458488898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <code>A</code>, destroying all the elements it contains.  <br /></td></tr>
<tr class="separator:a74b9ac2e545b1a8e3febffe458488898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42f9afe1397f5fba24397a495d995ff" id="r_aa42f9afe1397f5fba24397a495d995ff"><td class="memTemplParams" colspan="2"><a id="aa42f9afe1397f5fba24397a495d995ff" name="aa42f9afe1397f5fba24397a495d995ff"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aa42f9afe1397f5fba24397a495d995ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetZero</b> (Real *A, int64_t d)</td></tr>
<tr class="memdesc:aa42f9afe1397f5fba24397a495d995ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> of <code>A</code> to 0. <br /></td></tr>
<tr class="separator:aa42f9afe1397f5fba24397a495d995ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6937cb95337e67ec106791e9b528c3" id="r_afe6937cb95337e67ec106791e9b528c3"><td class="memTemplParams" colspan="2"><a id="afe6937cb95337e67ec106791e9b528c3" name="afe6937cb95337e67ec106791e9b528c3"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:afe6937cb95337e67ec106791e9b528c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetZero</b> (Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:afe6937cb95337e67ec106791e9b528c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> components of <code>A</code> to 0. <br /></td></tr>
<tr class="separator:afe6937cb95337e67ec106791e9b528c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a728d56ee563237fe943ebd333fa3f5" id="r_a2a728d56ee563237fe943ebd333fa3f5"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2a728d56ee563237fe943ebd333fa3f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a728d56ee563237fe943ebd333fa3f5">SetValue</a> (Real *A, int64_t d, const Real &amp;x)</td></tr>
<tr class="memdesc:a2a728d56ee563237fe943ebd333fa3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> components of <code>A</code> to 0.  <br /></td></tr>
<tr class="separator:a2a728d56ee563237fe943ebd333fa3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18ba9347ad4166201654eb4ad5c6972" id="r_ad18ba9347ad4166201654eb4ad5c6972"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:ad18ba9347ad4166201654eb4ad5c6972"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad18ba9347ad4166201654eb4ad5c6972">toString</a> (const Vect &amp;A, int64_t c, int64_t d, const char *sep=&quot; &quot;)</td></tr>
<tr class="memdesc:ad18ba9347ad4166201654eb4ad5c6972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing <code>A[c]</code> to <code>A[d-1]</code> formated as <code>[A[c]sep...sepA[d-1]]</code>.  <br /></td></tr>
<tr class="separator:ad18ba9347ad4166201654eb4ad5c6972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c697e5d81b902cbb4283a21104ac62b" id="r_a9c697e5d81b902cbb4283a21104ac62b"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a9c697e5d81b902cbb4283a21104ac62b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c697e5d81b902cbb4283a21104ac62b">toString</a> (const Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:a9c697e5d81b902cbb4283a21104ac62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing the first <code>d</code> components of the vector <code>A</code> as a string.  <br /></td></tr>
<tr class="separator:a9c697e5d81b902cbb4283a21104ac62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4590191d21abcdc4b30e0468ac416d" id="r_abe4590191d21abcdc4b30e0468ac416d"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Real &gt; </td></tr>
<tr class="memitem:abe4590191d21abcdc4b30e0468ac416d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe4590191d21abcdc4b30e0468ac416d">ProdScal</a> (const IntVec &amp;A, const IntVec &amp;B, int64_t n, Real &amp;D)</td></tr>
<tr class="memdesc:abe4590191d21abcdc4b30e0468ac416d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of vectors <code>A</code> and <code>B</code> truncated to their <code>n</code> first components, then puts the result in <code>D</code>.  <br /></td></tr>
<tr class="separator:abe4590191d21abcdc4b30e0468ac416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa6823947400db540862e204399ccc" id="r_a72aa6823947400db540862e204399ccc"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a72aa6823947400db540862e204399ccc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72aa6823947400db540862e204399ccc">Invert</a> (const IntVec &amp;A, IntVec &amp;B, int64_t n)</td></tr>
<tr class="memdesc:a72aa6823947400db540862e204399ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an input vector <code>A</code> of dimension <code>n+1</code> and fill the vector <code>B</code> with the values <code>[-A[n] -A[n-1] ... -A[1][1]</code>.  <br /></td></tr>
<tr class="separator:a72aa6823947400db540862e204399ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f1c63a3d050a201b80a4efc541e240" id="r_ab7f1c63a3d050a201b80a4efc541e240"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Real &gt; </td></tr>
<tr class="memitem:ab7f1c63a3d050a201b80a4efc541e240"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7f1c63a3d050a201b80a4efc541e240">CalcNorm</a> (const IntVec &amp;V, int64_t n, Real &amp;S, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:ab7f1c63a3d050a201b80a4efc541e240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>norm</code> norm of vector <code>V</code> trunctated to its <code>n</code> first components, and puts the result in <code>S</code>.  <br /></td></tr>
<tr class="separator:ab7f1c63a3d050a201b80a4efc541e240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45b3957599dec1d3c32b9dec0d0644c" id="r_aa45b3957599dec1d3c32b9dec0d0644c"><td class="memTemplParams" colspan="2"><a id="aa45b3957599dec1d3c32b9dec0d0644c" name="aa45b3957599dec1d3c32b9dec0d0644c"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:aa45b3957599dec1d3c32b9dec0d0644c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyPartVec</b> (Vect &amp;toVec, const Vect &amp;fromVec, int64_t c)</td></tr>
<tr class="memdesc:aa45b3957599dec1d3c32b9dec0d0644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <code>c</code> components of vector <code>fromVec</code> into vector <code>toVec</code>. <br /></td></tr>
<tr class="separator:aa45b3957599dec1d3c32b9dec0d0644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7ffaaa36d63e57ab488e8815a77bb7" id="r_aba7ffaaa36d63e57ab488e8815a77bb7"><td class="memTemplParams" colspan="2"><a id="aba7ffaaa36d63e57ab488e8815a77bb7" name="aba7ffaaa36d63e57ab488e8815a77bb7"></a>
template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:aba7ffaaa36d63e57ab488e8815a77bb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyPartMat</b> (Matr &amp;toMat, const Matr &amp;fromMat, int64_t r, int64_t c)</td></tr>
<tr class="memdesc:aba7ffaaa36d63e57ab488e8815a77bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <code>r</code> rows and <code>c</code> columns of matrix <code>fromMat</code> into matrix <code>toMat</code>. <br /></td></tr>
<tr class="separator:aba7ffaaa36d63e57ab488e8815a77bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bbadb519aa05a3a699329d0e08183e" id="r_a81bbadb519aa05a3a699329d0e08183e"><td class="memTemplParams" colspan="2"><a id="a81bbadb519aa05a3a699329d0e08183e" name="a81bbadb519aa05a3a699329d0e08183e"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a81bbadb519aa05a3a699329d0e08183e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyVect</b> (Vect &amp;A, const Vect &amp;B, int64_t n)</td></tr>
<tr class="memdesc:a81bbadb519aa05a3a699329d0e08183e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <code>n</code> components of vector <code>B</code> into vector <code>A</code>. <br /></td></tr>
<tr class="separator:a81bbadb519aa05a3a699329d0e08183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813a622816b9bdc2fc48e8315e16c7e9" id="r_a813a622816b9bdc2fc48e8315e16c7e9"><td class="memTemplParams" colspan="2">template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:a813a622816b9bdc2fc48e8315e16c7e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a813a622816b9bdc2fc48e8315e16c7e9">ModifVect</a> (Vect &amp;A, const Vect &amp;B, Scal x, int64_t n)</td></tr>
<tr class="memdesc:a813a622816b9bdc2fc48e8315e16c7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>.  <br /></td></tr>
<tr class="separator:a813a622816b9bdc2fc48e8315e16c7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4b9cba25e9e08b49137b70a3b3d95" id="r_a2fb4b9cba25e9e08b49137b70a3b3d95"><td class="memTemplParams" colspan="2">template&lt;typename Vect , typename Scal , typename Int &gt; </td></tr>
<tr class="memitem:a2fb4b9cba25e9e08b49137b70a3b3d95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2fb4b9cba25e9e08b49137b70a3b3d95">ModifVectModulo</a> (Vect &amp;A, const Vect &amp;B, Scal x, Int m, int64_t n)</td></tr>
<tr class="memdesc:a2fb4b9cba25e9e08b49137b70a3b3d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>, modulo m.  <br /></td></tr>
<tr class="separator:a2fb4b9cba25e9e08b49137b70a3b3d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80edc77542f933dcde8561a54d59c13b" id="r_a80edc77542f933dcde8561a54d59c13b"><td class="memTemplParams" colspan="2"><a id="a80edc77542f933dcde8561a54d59c13b" name="a80edc77542f933dcde8561a54d59c13b"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a80edc77542f933dcde8561a54d59c13b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ChangeSign</b> (Vect &amp;A, int64_t n)</td></tr>
<tr class="memdesc:a80edc77542f933dcde8561a54d59c13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sign (multiplies by -1) the first <code>n</code> components of vector <code>A</code>. <br /></td></tr>
<tr class="separator:a80edc77542f933dcde8561a54d59c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037fd4e351a079af3d672889e89666e0" id="r_a037fd4e351a079af3d672889e89666e0"><td class="memItemLeft" align="right" valign="top"><a id="a037fd4e351a079af3d672889e89666e0" name="a037fd4e351a079af3d672889e89666e0"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GCD2vect</b> (std::vector&lt; std::int64_t &gt; V, int64_t k, int64_t n)</td></tr>
<tr class="memdesc:a037fd4e351a079af3d672889e89666e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of <code>V[k],...,V[n-1]</code>. <br /></td></tr>
<tr class="separator:a037fd4e351a079af3d672889e89666e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrices</div></td></tr>
<tr class="memitem:a1f76eab56c1a9defffae5b8bf629290f" id="r_a1f76eab56c1a9defffae5b8bf629290f"><td class="memTemplParams" colspan="2"><a id="a1f76eab56c1a9defffae5b8bf629290f" name="a1f76eab56c1a9defffae5b8bf629290f"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a1f76eab56c1a9defffae5b8bf629290f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateMatr</b> (Real **&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a1f76eab56c1a9defffae5b8bf629290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to a square matrix <code>A</code> of dimensions \(d \times d\) and initializes its elements to 0. <br /></td></tr>
<tr class="separator:a1f76eab56c1a9defffae5b8bf629290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add086c03b1352ae2ed9413068d5e3f6d" id="r_add086c03b1352ae2ed9413068d5e3f6d"><td class="memTemplParams" colspan="2"><a id="add086c03b1352ae2ed9413068d5e3f6d" name="add086c03b1352ae2ed9413068d5e3f6d"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:add086c03b1352ae2ed9413068d5e3f6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateMatr</b> (Real **&amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:add086c03b1352ae2ed9413068d5e3f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the matrix <code>A</code> of dimensions  \(\text{line} \times
\text{col}\) and initializes its elements to 0. <br /></td></tr>
<tr class="separator:add086c03b1352ae2ed9413068d5e3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d33e22aad4f4a29a20c11bb96c7b02" id="r_a03d33e22aad4f4a29a20c11bb96c7b02"><td class="memTemplParams" colspan="2"><a id="a03d33e22aad4f4a29a20c11bb96c7b02" name="a03d33e22aad4f4a29a20c11bb96c7b02"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a03d33e22aad4f4a29a20c11bb96c7b02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateMatr</b> (IntMat &amp;A, int64_t d)</td></tr>
<tr class="memdesc:a03d33e22aad4f4a29a20c11bb96c7b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <code>A</code> to a square matrix of dimensions <code>d*d</code> and re-initializes its elements to 0. <br /></td></tr>
<tr class="separator:a03d33e22aad4f4a29a20c11bb96c7b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf8fb861104547f84a5d73c33401fe6" id="r_afcf8fb861104547f84a5d73c33401fe6"><td class="memTemplParams" colspan="2"><a id="afcf8fb861104547f84a5d73c33401fe6" name="afcf8fb861104547f84a5d73c33401fe6"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:afcf8fb861104547f84a5d73c33401fe6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateMatr</b> (IntMat &amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:afcf8fb861104547f84a5d73c33401fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <code>A</code> to a matrix of dimensions \(line \times col\) and re-initializes its elements to 0. <br /></td></tr>
<tr class="separator:afcf8fb861104547f84a5d73c33401fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3fbf56b76e1a95c0f935bb0acca3a4" id="r_a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b3fbf56b76e1a95c0f935bb0acca3a4">DeleteMatr</a> (Real **&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the \(d \times d\) matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7b6d86bbad87845663bfb8e8e00d06" id="r_adb7b6d86bbad87845663bfb8e8e00d06"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:adb7b6d86bbad87845663bfb8e8e00d06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb7b6d86bbad87845663bfb8e8e00d06">DeleteMatr</a> (Real **&amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:adb7b6d86bbad87845663bfb8e8e00d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the matrix <code>A</code> of dimension  \(\text{line} \times
\text{col}\).  <br /></td></tr>
<tr class="separator:adb7b6d86bbad87845663bfb8e8e00d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524" id="r_a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f66d14fcb15c8a2e358b9ab5e08b524">DeleteMatr</a> (IntMat &amp;A)</td></tr>
<tr class="memdesc:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <code><a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677" title="Sets x to 0.">clear()</a></code> method on <code>A</code>.  <br /></td></tr>
<tr class="separator:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb6cc508f7a12e043a9d39eab4e99c0" id="r_adfb6cc508f7a12e043a9d39eab4e99c0"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:adfb6cc508f7a12e043a9d39eab4e99c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfb6cc508f7a12e043a9d39eab4e99c0">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int64_t n)</td></tr>
<tr class="memdesc:adfb6cc508f7a12e043a9d39eab4e99c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(n \times n\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:adfb6cc508f7a12e043a9d39eab4e99c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620105c7b91ca77c4259bd116d48ed61" id="r_a620105c7b91ca77c4259bd116d48ed61"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:a620105c7b91ca77c4259bd116d48ed61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a620105c7b91ca77c4259bd116d48ed61">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:a620105c7b91ca77c4259bd116d48ed61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:a620105c7b91ca77c4259bd116d48ed61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4c9e2b77c4dc22c74401738c15c8b8" id="r_a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="memTemplParams" colspan="2">template&lt;typename MatT &gt; </td></tr>
<tr class="memitem:a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c4c9e2b77c4dc22c74401738c15c8b8">toStr</a> (const MatT &amp;mat, int64_t d1, int64_t d2, int64_t prec=2)</td></tr>
<tr class="memdesc:a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that is a representation of <code>mat</code>.  <br /></td></tr>
<tr class="separator:a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc093dc4ab413df7a7a08495c06677d1" id="r_adc093dc4ab413df7a7a08495c06677d1"><td class="memTemplParams" colspan="2"><a id="adc093dc4ab413df7a7a08495c06677d1" name="adc093dc4ab413df7a7a08495c06677d1"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:adc093dc4ab413df7a7a08495c06677d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ProductDiagonal</b> (const NTL::Mat&lt; Int &gt; &amp;A, long dim, Int &amp;prod)</td></tr>
<tr class="memdesc:adc093dc4ab413df7a7a08495c06677d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the diagonal elements of the matrix <code>A</code>, which is assumed to be square <code>dim x dim</code>. <br /></td></tr>
<tr class="separator:adc093dc4ab413df7a7a08495c06677d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025780512339ad633b6878b3663d6869" id="r_a025780512339ad633b6878b3663d6869"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a025780512339ad633b6878b3663d6869"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a025780512339ad633b6878b3663d6869">CheckTriangular</a> (const NTL::Mat&lt; Int &gt; &amp;A, long dim, const Int m)</td></tr>
<tr class="memdesc:a025780512339ad633b6878b3663d6869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <code>A</code> is triangular modulo <code>m</code>.  <br /></td></tr>
<tr class="separator:a025780512339ad633b6878b3663d6869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5df314f92821aa4256133b3342f986" id="r_abf5df314f92821aa4256133b3342f986"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:abf5df314f92821aa4256133b3342f986"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf5df314f92821aa4256133b3342f986">checkInverseModm</a> (const NTL::Mat&lt; Int &gt; &amp;A, const NTL::Mat&lt; Int &gt; &amp;B, const Int m)</td></tr>
<tr class="memdesc:abf5df314f92821aa4256133b3342f986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if A and B are m-dual to each other.  <br /></td></tr>
<tr class="separator:abf5df314f92821aa4256133b3342f986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04449fdf436107c5ef230401edf3a200" id="r_a04449fdf436107c5ef230401edf3a200"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a04449fdf436107c5ef230401edf3a200"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04449fdf436107c5ef230401edf3a200">calcDual</a> (const Matr &amp;A, Matr &amp;B, int64_t d, const Int &amp;m)</td></tr>
<tr class="memdesc:a04449fdf436107c5ef230401edf3a200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an upper triangular basis <code>A</code> and computes an m-dual lattice basis to this matrix.  <br /></td></tr>
<tr class="separator:a04449fdf436107c5ef230401edf3a200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debugging functions</div></td></tr>
<tr class="memitem:a852fa8fe7dda3213afd5db3e65caa43c" id="r_a852fa8fe7dda3213afd5db3e65caa43c"><td class="memItemLeft" align="right" valign="top"><a id="a852fa8fe7dda3213afd5db3e65caa43c" name="a852fa8fe7dda3213afd5db3e65caa43c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>myExit</b> (std::string msg)</td></tr>
<tr class="memdesc:a852fa8fe7dda3213afd5db3e65caa43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple error exit function, prints <code>msg</code> on exit. <br /></td></tr>
<tr class="separator:a852fa8fe7dda3213afd5db3e65caa43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Printing functions and operators</div></td></tr>
<tr class="memitem:a9c5c3904af8b547eb32bba8d42b5c3b1" id="r_a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memTemplParams" colspan="2">template&lt;class K , class T , class C , class A &gt; </td></tr>
<tr class="memitem:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c5c3904af8b547eb32bba8d42b5c3b1">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; K, T, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for maps.  <br /></td></tr>
<tr class="separator:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00572b373d97cc0227547867bd1cde0d" id="r_a00572b373d97cc0227547867bd1cde0d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a00572b373d97cc0227547867bd1cde0d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00572b373d97cc0227547867bd1cde0d">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a00572b373d97cc0227547867bd1cde0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <br /></td></tr>
<tr class="separator:a00572b373d97cc0227547867bd1cde0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddcbc9a5e063f35176f9c48d38f2650" id="r_a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memTemplParams" colspan="2">template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ddcbc9a5e063f35176f9c48d38f2650">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <br /></td></tr>
<tr class="separator:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b28ac9e1e15b5ede018202a73fe664" id="r_a97b28ac9e1e15b5ede018202a73fe664"><td class="memTemplParams" colspan="2">template&lt;class K , class C , class A &gt; </td></tr>
<tr class="memitem:a97b28ac9e1e15b5ede018202a73fe664"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97b28ac9e1e15b5ede018202a73fe664">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; K, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a97b28ac9e1e15b5ede018202a73fe664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for sets.  <br /></td></tr>
<tr class="separator:a97b28ac9e1e15b5ede018202a73fe664"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac9adbd421a1148216c8eac1b7d96a5b8" id="r_ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memItemLeft" align="right" valign="top"><a id="ac9adbd421a1148216c8eac1b7d96a5b8" name="ac9adbd421a1148216c8eac1b7d96a5b8"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_LONG_DOUBLE</b> = 9007199254740992.0</td></tr>
<tr class="memdesc:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\). <br /></td></tr>
<tr class="separator:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f464bde0cd79b7bbc47ff090e49b31" id="r_ae5f464bde0cd79b7bbc47ff090e49b31"><td class="memItemLeft" align="right" valign="top"><a id="ae5f464bde0cd79b7bbc47ff090e49b31" name="ae5f464bde0cd79b7bbc47ff090e49b31"></a>
const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>TWO_EXP</b> []</td></tr>
<tr class="memdesc:ae5f464bde0cd79b7bbc47ff090e49b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\). <br /></td></tr>
<tr class="separator:ae5f464bde0cd79b7bbc47ff090e49b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> namespace. </p>
<p>These functions are in the latticetester namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0d2f9ab69a9d586b8273cbb29bb105fe" name="a0d2f9ab69a9d586b8273cbb29bb105fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">&#9670;&#160;</a></span>CalcType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">LatticeTester::CalcType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of calculation is considered for the \(P_{\alpha}\) test. </p>
<p><a class="anchor" id="REF__Const_CalcType_def"></a>Is this used anywhere? ************</p>
<p><code>PAL</code> is for the \(P_{\alpha}\) test. <br  />
 <code>BAL</code> is for the bound on the \(P_{\alpha}\) test. <br  />
 <code>NORMPAL</code> is for the \(P_{\alpha}\) test <code>PAL</code>, with the result normalized over the <code>BAL</code> bound. <br  />
 <code>SEEKPAL</code> is for the \(P_{\alpha}\) seek, which searches for good values of the multiplier. </p>

</div>
</div>
<a id="a2cf3c4f4181718b7adc6f5e4513695a0" name="a2cf3c4f4181718b7adc6f5e4513695a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf3c4f4181718b7adc6f5e4513695a0">&#9670;&#160;</a></span>CriterionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">LatticeTester::CriterionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merit criteria to measure the quality of generators or lattices. </p>
<p>TO DO: this list is not very clear. Maybe outdated. ****************</p>
<p><code>LENGTH</code>: Only using the length of the shortest vector as a criterion. <code>SPECTRAL</code>: figure of merit \(S_T\) based on the spectral test.<br  />
 <code>BEYER</code>: figure of merit is the Beyer quotient \(Q_T\).<br  />
 <code>PALPHA</code>: figure of merit based on \(P_{\alpha}\).<br  />
 <code>BOUND_JS</code>: figure of merit based on the Joe-Sinescu bound <b>[rSIN08a]</b>.<br  />
 ??? </p>

</div>
</div>
<a id="a5bf461b8f167cc8c7ebebc8ee6a96ee4" name="a5bf461b8f167cc8c7ebebc8ee6a96ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">&#9670;&#160;</a></span>DecompTypeBB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">LatticeTester::DecompTypeBB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two possible ways of obtaining a triangular matrix to compute the bounds in the BB algorithm. </p>
<p><code>CHOLESKY</code>: use a lower-triangular matrix obtained as the Cholesky decomposition of the matrix of scalar products. <code>TRIANGULAR</code>: use a lower-triangular basis </p>

</div>
</div>
<a id="a5e9e347d07097a1a3c82f1699ff93d58" name="a5e9e347d07097a1a3c82f1699ff93d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9e347d07097a1a3c82f1699ff93d58">&#9670;&#160;</a></span>MeritType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">LatticeTester::MeritType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two different types of figures of merit. </p>
<p><code>MERITM</code>: based on shortest vector. <code>MERITQ</code>: based on Beyer quotient. </p>

</div>
</div>
<a id="ab747c1cbb0f5e47fef711b62327a8e90" name="ab747c1cbb0f5e47fef711b62327a8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab747c1cbb0f5e47fef711b62327a8e90">&#9670;&#160;</a></span>NormaType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">LatticeTester::NormaType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different types of normalizations that can be used for shortest-vector lengths. </p>
<p>Corresponds to different ways of approximating the Hermite constants <code>gamma_t</code>.</p>
<p><code>BESTLAT</code>: the value used for \(d_t^*\) corresponds to the best lattice.<br  />
 <code>BESTUPBOUND</code>: the value used for \(d_t^*\) corresponds to the best bound known to us.<br  />
 <code>LAMINATED</code>: the value used for \(d_t^*\) corresponds to the best <em>laminated</em> lattice.<br  />
 <code>ROGERS</code>: the value for \(d_t^*\) is obtained from <em>Rogers’</em> bound on the density of sphere packing.<br  />
 <code>MINKL1</code>: the value for \(d_t^*\) is obtained from the theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_1\) norm.<br  />
 <code>MINKHLAW</code>: the value for \(d_t^*\) is obtained from <em>Minkowski’</em> theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_2\) norm.<br  />
 <code>NONE</code>: no normalization will be used.<br  />
 </p>

</div>
</div>
<a id="a9770e4d57aa715e249cd7e700c6f37e4" name="a9770e4d57aa715e249cd7e700c6f37e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9770e4d57aa715e249cd7e700c6f37e4">&#9670;&#160;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">LatticeTester::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The available norm types to measure the length of vectors. </p>
<p>For \(X = (x_1,…,x_t)\):<br  />
 <code>SUPNORM</code> corresponds to \(\Vert X\Vert= \max(|x_1|,…,|x_t|)\).<br  />
 <code>L1NORM</code> corresponds to \(\Vert X\Vert= |x_1|+\cdots+|x_t|\).<br  />
 <code>L2NORM</code> corresponds to \(\Vert X\Vert= (x_1^2+\cdots+x_t^2)^{1/2}\).<br  />
 <code>ZAREMBANORM</code> corresponds to \(\Vert X\Vert= \max(1, |x_1|)\cdots\max(1, |x_t|)\). </p>

</div>
</div>
<a id="ad78f099c800f4c648134967a45b91058" name="ad78f099c800f4c648134967a45b91058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f099c800f4c648134967a45b91058">&#9670;&#160;</a></span>OutputType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad78f099c800f4c648134967a45b91058">LatticeTester::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different choices of output formats. </p>
<p><code>TERM</code>: the results will appear only on the terminal screen.<br  />
 <code>RES</code>: the results will be in plain text and sent to a <code>.res</code> file.<br  />
 <code>TEX</code>: the results will be in a LaTeX file with extension <code>.tex</code>.<br  />
 <code>GEN</code>: a list of retained generators will be sent to a file with extension <code>.gen</code>, in a specific format so this list can be read again for further analysis. </p>

</div>
</div>
<a id="a94f96ff406f8b56147a2b7fd96209cb2" name="a94f96ff406f8b56147a2b7fd96209cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f96ff406f8b56147a2b7fd96209cb2">&#9670;&#160;</a></span>PrecisionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2">LatticeTester::PrecisionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This can be supersed by the Real type. </p>
<p>Types of precision that the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> can use for real numbers: <code>DOUBLE</code> &ndash; double <code>QUADRUPLE</code> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <code>XDOUBLE</code> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <code>RR</code> &ndash; RR (arbitrary precision floating point). The choice <code>DOUBLE</code> is usually the fastest, but may be prone to roundoff errors and/or overflow. See <code><a href="https://github.com/u-u-h/NTL/blob/master/doc/LLL.txt">https://github.com/u-u-h/NTL/blob/master/doc/LLL.txt</a></code>. </p>

</div>
</div>
<a id="aad7b917d5ef7e8167bc50aa56109faff" name="aad7b917d5ef7e8167bc50aa56109faff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7b917d5ef7e8167bc50aa56109faff">&#9670;&#160;</a></span>ProblemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aad7b917d5ef7e8167bc50aa56109faff">LatticeTester::ProblemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of problems that <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> can handle. </p>
<p>Not sure if we still need this. ******* </p>

</div>
</div>
<a id="a1ff6c9ee29ca0bac6c63d2622508aa46" name="a1ff6c9ee29ca0bac6c63d2622508aa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff6c9ee29ca0bac6c63d2622508aa46">&#9670;&#160;</a></span>ProjConstructType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">LatticeTester::ProjConstructType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two possible ways of computing the basis for a projection. </p>
<p><code>LLLPROJ</code>: uses LLL reduction. <code>UPPERTRIPROJ</code>: use an upper-triangular basis construction. </p>

</div>
</div>
<a id="af2a213e64bd54d3e33a7aff0f80068cb" name="af2a213e64bd54d3e33a7aff0f80068cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a213e64bd54d3e33a7aff0f80068cb">&#9670;&#160;</a></span>ReductionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">LatticeTester::ReductionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of all the possible lattice reductions implemented in <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a></code>. </p>
<p><code>PAIR</code>: Pairwise reductions only. <code>LLL</code>: LLL reduction only. <code>BKZ</code>: block Korkine-Zolotarev reduction only. <code>BB</code>: direct shortest vector search with BB (no pre-red.). <code>PAIRBB</code>: Pairwise reduction followed by BB. <code>LLLBB</code>: LLL followed by BB. <code>BKZBB</code>: BKZ followed by BB. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a67515c2643b5f7029486e8118ede05d6" name="a67515c2643b5f7029486e8118ede05d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67515c2643b5f7029486e8118ede05d6">&#9670;&#160;</a></span>BernoulliPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::BernoulliPoly </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\). </p>
<p>The first Bernoulli polynomials are:           </p><p class="formulaDsp">
\begin{align*}
B_0(x) &amp;= 1  \\
B_1(x) &amp;= x - 1/2  \\
B_2(x) &amp;= x^2-x+1/6  \\
B_3(x) &amp;= x^3 - 3x^2/2 + x/2  \\
B_4(x) &amp;= x^4-2x^3+x^2-1/30 \\
B_5(x) &amp;= x^5 - 5x^4/2 + 5x^3/3 - x/6  \\
B_6(x) &amp;= x^6-3x^5+5x^4/2-x^2/2+1/42  \\
B_7(x) &amp;= x^7 - 7x^6/2 +  7x^5/2 - 7x^3/6 + x/6  \\
B_8(x) &amp;= x^8-4x^7+14x^6/3 - 7x^4/3 +2x^2/3-1/30.
\end{align*}
</p>
<p> Only degrees \(n \le 8\) are programmed for now. </p>

</div>
</div>
<a id="a04449fdf436107c5ef230401edf3a200" name="a04449fdf436107c5ef230401edf3a200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04449fdf436107c5ef230401edf3a200">&#9670;&#160;</a></span>calcDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::calcDual </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes an upper triangular basis <code>A</code> and computes an m-dual lattice basis to this matrix. </p>
<p>For this algorithm to work, <code>A</code> has to be upper triangular and all the coefficients on the diagonal have to divide <code>m</code>.</p>
<p>For <code>B</code> to be <code>m</code>-dual to <code>A</code>, we have to have that \(AB^t = mI\). It is quite easy to show that, knowing <code>A</code> is upper triangular, <code>B</code> will be a lower triangular matrix with <code>A(i,i)*B(i,i) = m</code> for all <code>i</code> and \( A_i \cdot B_j = 0\) for \(i\neq j\). To get the second condition, we simply have to recursively take for each line </p><p class="formulaDsp">
\[B_{i,j} = -\frac{1}{A_{j,j}}\sum_{k=j+1}^i A_{j,k} B_{i,k}.\]
</p>
 
<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677">NTL::clear()</a>, and <a class="el" href="#a76b74332cd4ded85d51dc6020b930772">DivideRound()</a>.</p>

</div>
</div>
<a id="ab7f1c63a3d050a201b80a4efc541e240" name="ab7f1c63a3d050a201b80a4efc541e240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f1c63a3d050a201b80a4efc541e240">&#9670;&#160;</a></span>CalcNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcNorm </td>
          <td>(</td>
          <td class="paramtype">const IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a></td>          <td class="paramname"><span class="paramname"><em>norm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the <code>norm</code> norm of vector <code>V</code> trunctated to its <code>n</code> first components, and puts the result in <code>S</code>. </p>
<p><code>Scal</code> has to be a floating point type. For the L2 norm, it returns the square norm instead. </p>

<p class="reference">References <a class="el" href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">abs()</a>, and <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d0/dea/classLatticeTester_1_1ReducerBB.html#a2af897ebb1841f87caf05c902a8a1f8b">LatticeTester::ReducerBB&lt; Int, Real &gt;::shortestVector()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#af80ca4c4d06357cd92a5622d84e30887">LatticeTester::IntLattice&lt; Int, Real &gt;::updateDualVecNorm()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#aac7999db9ff31a4c65b249595d56d002">LatticeTester::IntLattice&lt; Int, Real &gt;::updateDualVecNorm()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#af46cbbb85393e9722b2733a637c5e7bb">LatticeTester::IntLattice&lt; Int, Real &gt;::updateSingleDualVecNorm()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a352c084e9c29ebf84450d1171d624491">LatticeTester::IntLattice&lt; Int, Real &gt;::updateSingleVecNorm()</a>, and <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#affdbc003b45d7155dafc3db7499d4b6e">LatticeTester::IntLattice&lt; Int, Real &gt;::updateVecNorm()</a>.</p>

</div>
</div>
<a id="abf5df314f92821aa4256133b3342f986" name="abf5df314f92821aa4256133b3342f986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5df314f92821aa4256133b3342f986">&#9670;&#160;</a></span>checkInverseModm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::checkInverseModm </td>
          <td>(</td>
          <td class="paramtype">const NTL::Mat&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Mat&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if A and B are m-dual to each other. </p>
<p>They must be square with the same dimensions. Returns <code>true</code> if <code>AB = mI</code>, false otherwise. </p>

<p class="reference">References <a class="el" href="#abe4590191d21abcdc4b30e0468ac416d">ProdScal()</a>.</p>

</div>
</div>
<a id="a025780512339ad633b6878b3663d6869" name="a025780512339ad633b6878b3663d6869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025780512339ad633b6878b3663d6869">&#9670;&#160;</a></span>CheckTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::CheckTriangular </td>
          <td>(</td>
          <td class="paramtype">const NTL::Mat&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <code>A</code> is triangular modulo <code>m</code>. </p>
<p>This will return <code>true</code> if all the elements under the diagonal are equal to zero modulo <code>m</code> and <code>false</code> otherwise. If <code>m</code> is <code>0</code>, this function simply verifies that the matrix is triangular. </p>

</div>
</div>
<a id="a620105c7b91ca77c4259bd116d48ed61" name="a620105c7b91ca77c4259bd116d48ed61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620105c7b91ca77c4259bd116d48ed61">&#9670;&#160;</a></span>CopyMatr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>. </p>
<p>This function does not check for sizes, so <code>A</code> and <code>B</code> both have to be at leat \(line \times col\). </p>

</div>
</div>
<a id="adfb6cc508f7a12e043a9d39eab4e99c0" name="adfb6cc508f7a12e043a9d39eab4e99c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb6cc508f7a12e043a9d39eab4e99c0">&#9670;&#160;</a></span>CopyMatr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(n \times n\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>. </p>
<p>This function does not check for sizes, so <code>A</code> and <code>B</code> both have to be at leat \(n \times n\). </p>

</div>
</div>
<a id="a0416b061a693a6e604d4cc99b14a7050" name="a0416b061a693a6e604d4cc99b14a7050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0416b061a693a6e604d4cc99b14a7050">&#9670;&#160;</a></span>CreateVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory to <code>A</code> as an array of <code>Real</code> of dimension <code>d</code> and initializes its elements to 0. </p>
<p><code>Real</code> has to be a numeric type. </p>

</div>
</div>
<a id="af40f02397dea42344f2c4b6016f5e4f0" name="af40f02397dea42344f2c4b6016f5e4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40f02397dea42344f2c4b6016f5e4f0">&#9670;&#160;</a></span>CreateVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the vector <code>A</code> of dimensions <code>d+1</code> and initializes its elements to 0. </p>
<p>The type <code>Vect</code> must have a method <code>SetLength</code>, as for <code>Vec&lt;T&gt;</code> in <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>. </p>

</div>
</div>
<a id="a0f66d14fcb15c8a2e358b9ab5e08b524" name="a0f66d14fcb15c8a2e358b9ab5e08b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f66d14fcb15c8a2e358b9ab5e08b524">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the <code><a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677" title="Sets x to 0.">clear()</a></code> method on <code>A</code>. </p>
<p><code>A</code> has to have a <code><a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677" title="Sets x to 0.">clear()</a></code> method that frees the memory allocated to it. </p>

</div>
</div>
<a id="a2b3fbf56b76e1a95c0f935bb0acca3a4" name="a2b3fbf56b76e1a95c0f935bb0acca3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3fbf56b76e1a95c0f935bb0acca3a4">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the \(d \times d\) matrix <code>A</code>. </p>
<p>This will not free all the memory allocated to <code>A</code> if <code>A</code> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="adb7b6d86bbad87845663bfb8e8e00d06" name="adb7b6d86bbad87845663bfb8e8e00d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7b6d86bbad87845663bfb8e8e00d06">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the matrix <code>A</code> of dimension  \(\text{line} \times
\text{col}\). </p>
<p>This will not free all the memory allocated to <code>A</code> if <code>A</code> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="a3290d1c59f58412753021d37fd9059c3" name="a3290d1c59f58412753021d37fd9059c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3290d1c59f58412753021d37fd9059c3">&#9670;&#160;</a></span>DeleteVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <code>A</code>. </p>
<p>This calls <code>delete[]</code> on <code>A</code> so trying to access <code>A</code> after using this is unsafe. </p>

</div>
</div>
<a id="a74b9ac2e545b1a8e3febffe458488898" name="a74b9ac2e545b1a8e3febffe458488898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b9ac2e545b1a8e3febffe458488898">&#9670;&#160;</a></span>DeleteVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <code>A</code>, destroying all the elements it contains. </p>
<p><code>Vect</code> type has to have a <code>kill()</code> method that deallocates all the elements in the vector. </p>

</div>
</div>
<a id="aeccbd231b4002cadbaac0157871f5570" name="aeccbd231b4002cadbaac0157871f5570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccbd231b4002cadbaac0157871f5570">&#9670;&#160;</a></span>Divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder  \(r = a
\bmod b\). </p>
<p>Truncates \(q\) to the nearest integer toward 0. One always has \(a = qb + r\) and \(|r| &lt; |b|\). This works with std::int64_t, NTL::ZZ and real numbers.</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td><td class="r bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(-2\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\) </td><td class="r bl br">\(-2\)  </td></tr>
</table>
</center><center></center> 
<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/d81/classLatMRG_1_1Modulus.html#a8eb0ea4721f0b424ca021c900f79c57e">LatMRG::Modulus&lt; Int &gt;::reduceM()</a>.</p>

</div>
</div>
<a id="a76b74332cd4ded85d51dc6020b930772" name="a76b74332cd4ded85d51dc6020b930772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b74332cd4ded85d51dc6020b930772">&#9670;&#160;</a></span>DivideRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DivideRound </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). </p>
<p>This works with std::int64_t, NTL::ZZ and real numbers. </p>

<p class="reference">Referenced by <a class="el" href="#a04449fdf436107c5ef230401edf3a200">calcDual()</a>, and <a class="el" href="#a938bceedde41f1318302ed9037dc0f83">mDualUpperTriangularOld96()</a>.</p>

</div>
</div>
<a id="abfe3d98ab5a4c91cac2ef0fa59ec897d" name="abfe3d98ab5a4c91cac2ef0fa59ec897d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">&#9670;&#160;</a></span>Euclide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Euclide </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the greater common divisor of <code>A</code> and <code>B</code> with Euclid's algorithm. </p>
<p>This will store this gcd in <code>G</code> and also the linear combination that permits to get <code>G</code> from <code>A</code> and <code>B</code>. This function should work with std::int64_t and NTL::ZZ.</p>
<p>For \(A\) and \(B\) this will assign to \(C\), \(D\), \(E\), \(F\) and \(G\) values such that:    </p><p class="formulaDsp">
\begin{align*}
   C a + D b &amp; = G = \mbox{GCD } (a,b)\\
    E a + F b &amp; = 0.
\end{align*}
</p>
 
<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677">NTL::clear()</a>, <a class="el" href="../../d2/d5a/namespaceNTL.html#a1629b29c99a1aed8f591c523c9047519">NTL::IsZero()</a>, <a class="el" href="#aa9056e4da6e74d83c6061650caf9e59f">Quotient()</a>, <a class="el" href="../../d2/d5a/namespaceNTL.html#a968f8ba311c0012dd1ee4f024ae54e51">NTL::set()</a>, and <a class="el" href="#ad4d16fed8fda92252dc423db28136932">swap9()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/d5e/namespaceLatMRG.html#a671c2035934701d0aad78ff85a41a11f">LatMRG::getLatCombo()</a>.</p>

</div>
</div>
<a id="a0bb56e7569fb24800973df89d757f2fd" name="a0bb56e7569fb24800973df89d757f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb56e7569fb24800973df89d757f2fd">&#9670;&#160;</a></span>FourierC1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierC1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series (see <b>[vJOE92b]</b>) </p>
<p class="formulaDsp">
\[
S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}.
\]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="ab5f708fa0e8d6aa53427b3e8927f5504" name="ab5f708fa0e8d6aa53427b3e8927f5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f708fa0e8d6aa53427b3e8927f5504">&#9670;&#160;</a></span>FourierE1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series. </p>
<p class="formulaDsp">
\[
G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\;  \frac{e^{2\pi i h x}}{|h|},
\]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes. Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="a3aefa49a034495dcc46721c275f329b0" name="a3aefa49a034495dcc46721c275f329b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aefa49a034495dcc46721c275f329b0">&#9670;&#160;</a></span>Harmonic2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic2 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum. </p>
<p class="formulaDsp">
\[
\sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|},
\]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum. </p>

</div>
</div>
<a id="a72aa6823947400db540862e204399ccc" name="a72aa6823947400db540862e204399ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa6823947400db540862e204399ccc">&#9670;&#160;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Invert </td>
          <td>(</td>
          <td class="paramtype">const IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes an input vector <code>A</code> of dimension <code>n+1</code> and fill the vector <code>B</code> with the values <code>[-A[n] -A[n-1] ... -A[1][1]</code>. </p>
<p><code>B</code> is assumed to be of dimension at least <code>n+1</code>. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

</div>
</div>
<a id="a71110e4d0e1c979d7f5da2593e8edddb" name="a71110e4d0e1c979d7f5da2593e8edddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71110e4d0e1c979d7f5da2593e8edddb">&#9670;&#160;</a></span>lFactorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::lFactorial </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\). </p>
<p>Might throw an error if <code>t</code> is too large or if std::int64_t cannot contain the factorial asked for. </p>

</div>
</div>
<a id="a0375e124633660cc7ef0ba824d20401b" name="a0375e124633660cc7ef0ba824d20401b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0375e124633660cc7ef0ba824d20401b">&#9670;&#160;</a></span>LLLBasisConstruction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::LLLBasisConstruction </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <code>LLLConstruction0</code>, except that this function adds implicitly the vectors \(m \mathbf{e}_i\) to the generating set, so it always returns a square matrix. </p>
<p>The matrix <code>gen</code> is not resized by this function, so it can remain larger than the lattice dimension. </p>

</div>
</div>
<a id="adf38db6c503b603580edb998ab3dfb3a" name="adf38db6c503b603580edb998ab3dfb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf38db6c503b603580edb998ab3dfb3a">&#9670;&#160;</a></span>lowerTriangularBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::lowerTriangularBasis </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <code>gen</code> and iteratively transforms it into a lower triangular lattice basis into the matrix <code>basis</code>. </p>
<p>This lattice is assumed to contain all the vectors of the form \(m \mathbf{e}_j\), so these vectors are added implicitly to the generating set. Apart from that, all the entries of <code>gen</code> given as input are assumed to be reduced modulo the scaling factor <code>m</code> and all the computations are done modulo <code>m</code>. The matrix <code>basis</code> is assumed to be large enough to contain the new basis, whose dimension should be the number of columns taken from <code>gen</code>. After the execution, <code>gen</code> will contain irrelevant information (garbage) and <code>basis</code> will contain an upper triangular basis. The algorithm is explained in the lattice tester guide. Important: <code>gen</code> and <code>basis</code> must be different <code>IntMat</code> objects.</p>
<p>When <code>r</code> and/or <code>c</code> are strictly positive, they specify the numbers of rows and columns of <code>gen</code> that are actually used, as in <code>LLLConstruction0</code>. The matrix <code>gen</code> is never resized. The new basis should be c x c. </p>

<p class="reference">References <a class="el" href="#a14db19d396c104b730dd5ea23a7752b5">gcd()</a>, and <a class="el" href="#ace733f06613d555cb7c6fb617e8a33b7">ModuloTowardZero()</a>.</p>

</div>
</div>
<a id="a7599453daee81235947f198aa0fdabd2" name="a7599453daee81235947f198aa0fdabd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7599453daee81235947f198aa0fdabd2">&#9670;&#160;</a></span>mDualLowerTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualLowerTriangular </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a lower-triangular basis matrix <code>basis</code> and computes the m-dual basis <code>basisDual</code>. </p>
<p>The function assumes that each coefficient on the diagonal of <code>basis</code> is nonzero and divides <code>m</code>. That is, the basis matrix must be square and m-invertible. Since the basis is lower triangular, its m-dual will be upper triangular. When <code>dim &gt; 0</code>, it must give the number of rows and columns of the matrix <code>basis</code> that is actually used. Otherwise (by default) the function uses <code>basis.numCols()</code>. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677">NTL::clear()</a>.</p>

</div>
</div>
<a id="a879bb70764843a663c4a22e993cd1d8b" name="a879bb70764843a663c4a22e993cd1d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879bb70764843a663c4a22e993cd1d8b">&#9670;&#160;</a></span>mDualUpperTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangular </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a upper triangular basis matrix <code>basis</code> and computes the m-dual basis <code>basisDual</code>. </p>
<p>This function is the equivalent of mDualLowerTriangular for upper-triangular matrices. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677">NTL::clear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html#ab9bc9f6c6fa16692ea80097c67a11c99">LatMRG::MRGLattice&lt; Int, Real &gt;::buildProjectionDual()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a3fea90bfea52f743f26a902cf01b9387">LatticeTester::IntLattice&lt; Int, Real &gt;::buildProjectionDual()</a>, <a class="el" href="../../d9/d4e/classLatticeTester_1_1MRGLattice.html#af850c43f69ffe995c2829254b953263e">LatticeTester::MRGLattice&lt; Int, Real &gt;::buildProjectionDual()</a>, and <a class="el" href="../../da/dc4/classLatMRG_1_1MRGLatticeLac.html#a818c228acb0a6f152828bfa23c42b7c0">LatMRG::MRGLatticeLac&lt; Int, Real &gt;::MRGLatticeLac()</a>.</p>

</div>
</div>
<a id="a938bceedde41f1318302ed9037dc0f83" name="a938bceedde41f1318302ed9037dc0f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938bceedde41f1318302ed9037dc0f83">&#9670;&#160;</a></span>mDualUpperTriangularOld96()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangularOld96 </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function does essentially the same thing as <code>mDualUpperTriangular</code>, but the algorithm is slightly different. </p>
<p>It uses the method described in <b>[rCOU96a]</b>. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677">NTL::clear()</a>, <a class="el" href="#a76b74332cd4ded85d51dc6020b930772">DivideRound()</a>, <a class="el" href="#a14db19d396c104b730dd5ea23a7752b5">gcd()</a>, and <a class="el" href="../../d2/d5a/namespaceNTL.html#a1629b29c99a1aed8f591c523c9047519">NTL::IsZero()</a>.</p>

</div>
</div>
<a id="a813a622816b9bdc2fc48e8315e16c7e9" name="a813a622816b9bdc2fc48e8315e16c7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813a622816b9bdc2fc48e8315e16c7e9">&#9670;&#160;</a></span>ModifVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModifVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>. </p>
<p>This will modify <code>A</code>. This does weird type conversions and may not work well if different types are used. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

</div>
</div>
<a id="a2fb4b9cba25e9e08b49137b70a3b3d95" name="a2fb4b9cba25e9e08b49137b70a3b3d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb4b9cba25e9e08b49137b70a3b3d95">&#9670;&#160;</a></span>ModifVectModulo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect , typename Scal , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModifVectModulo </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>, modulo m. </p>
<p>This will modify <code>A</code>. The elements that are not multiples of <code>m</code> are reduced mod m. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

</div>
</div>
<a id="a33b2ac0aaf5689dbf1f2225dbf14b327" name="a33b2ac0aaf5689dbf1f2225dbf14b327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b2ac0aaf5689dbf1f2225dbf14b327">&#9670;&#160;</a></span>Modulo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of a/b and stores its positive equivalent mod b in r. </p>
<p>This works with std::int64_t, NTL::ZZ and real numbers. </p>

<p class="reference">Referenced by <a class="el" href="../../d0/d8f/classLatMRG_1_1LCGLattice.html#ac59d4ab2b5971f4c7e6ae9861078c26e">LatMRG::LCGLattice&lt; Int, Real &gt;::incDim()</a>, and <a class="el" href="../../df/d81/classLatMRG_1_1Modulus.html#a8eb0ea4721f0b424ca021c900f79c57e">LatMRG::Modulus&lt; Int &gt;::reduceM()</a>.</p>

</div>
</div>
<a id="ace733f06613d555cb7c6fb617e8a33b7" name="ace733f06613d555cb7c6fb617e8a33b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace733f06613d555cb7c6fb617e8a33b7">&#9670;&#160;</a></span>ModuloTowardZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModuloTowardZero </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the element <code>r = a mod b</code> that is closest to 0. </p>
<p>Assumes <code>b &gt; 0</code>. For example, <code>8 mod 11 = -3</code>, <code>-2 mod 11 = -2</code>, <code>-10 mod 11 = 1</code>. </p>

<p class="reference">Referenced by <a class="el" href="#adf38db6c503b603580edb998ab3dfb3a">lowerTriangularBasis()</a>, <a class="el" href="#a330c8d1822bd62d27f7708e04e409a96">mDualLowerTriangularMod0()</a>, <a class="el" href="#a541c52e31adea978279ddd93a5cbdc18">mDualUpperTriangularMod0()</a>, and <a class="el" href="#ac0699288204d864638ec9cc3461192bc">upperTriangularBasis()</a>.</p>

</div>
</div>
<a id="a9c5c3904af8b547eb32bba8d42b5c3b1" name="a9c5c3904af8b547eb32bba8d42b5c3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5c3904af8b547eb32bba8d42b5c3b1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; K, T, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for maps. </p>
<p>Formats a map as: <code>{ key1=&gt;val1, ..., keyN=&gt;valN }</code>. </p>

</div>
</div>
<a id="a00572b373d97cc0227547867bd1cde0d" name="a00572b373d97cc0227547867bd1cde0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00572b373d97cc0227547867bd1cde0d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a pair as: <code>(first,second)</code>. </p>

</div>
</div>
<a id="a97b28ac9e1e15b5ede018202a73fe664" name="a97b28ac9e1e15b5ede018202a73fe664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b28ac9e1e15b5ede018202a73fe664">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; K, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for sets. </p>
<p>Formats a set as: <code>{ val1, ..., valN }</code>. </p>

</div>
</div>
<a id="a0ddcbc9a5e063f35176f9c48d38f2650" name="a0ddcbc9a5e063f35176f9c48d38f2650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddcbc9a5e063f35176f9c48d38f2650">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a vector as: <code>[ val1, ..., valN ]</code>. </p>

</div>
</div>
<a id="abe4590191d21abcdc4b30e0468ac416d" name="abe4590191d21abcdc4b30e0468ac416d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4590191d21abcdc4b30e0468ac416d">&#9670;&#160;</a></span>ProdScal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProdScal </td>
          <td>(</td>
          <td class="paramtype">const IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar product of vectors <code>A</code> and <code>B</code> truncated to their <code>n</code> first components, then puts the result in <code>D</code>. </p>
<p>There is a lot to consider when passing types to this function. The best is for <code>Vect1</code> to be the same type as <code>Vect2</code> and for <code>Scal</code> to be the same as <code>Int</code>, and that those types are the ones stored in <code>Vect1</code> and <code>Vect2</code>.</p>
<p><b>WARNING</b>: This uses so many types without check about them and also assumes all those types can be converted to each other without problem. This is used in some places to compute a floating point norm of vectors with integers values. Take care when using this function. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a7cf43dd173a6dc96e12ce9ec875a26b1">LatticeTester::IntLattice&lt; Int, Real &gt;::checkDuality()</a>, <a class="el" href="#abf5df314f92821aa4256133b3342f986">checkInverseModm()</a>, <a class="el" href="../../d0/dea/classLatticeTester_1_1ReducerBB.html#a2af897ebb1841f87caf05c902a8a1f8b">LatticeTester::ReducerBB&lt; Int, Real &gt;::shortestVector()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a0d107cc11bf25a6373d9d64731010a0f">LatticeTester::IntLattice&lt; Int, Real &gt;::updateDualScalL2Norm()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#af80ca4c4d06357cd92a5622d84e30887">LatticeTester::IntLattice&lt; Int, Real &gt;::updateDualVecNorm()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#aac7999db9ff31a4c65b249595d56d002">LatticeTester::IntLattice&lt; Int, Real &gt;::updateDualVecNorm()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a3b67a8e86802650179193605f0d85fb1">LatticeTester::IntLattice&lt; Int, Real &gt;::updateScalL2Norm()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#af46cbbb85393e9722b2733a637c5e7bb">LatticeTester::IntLattice&lt; Int, Real &gt;::updateSingleDualVecNorm()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a352c084e9c29ebf84450d1171d624491">LatticeTester::IntLattice&lt; Int, Real &gt;::updateSingleVecNorm()</a>, and <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#affdbc003b45d7155dafc3db7499d4b6e">LatticeTester::IntLattice&lt; Int, Real &gt;::updateVecNorm()</a>.</p>

</div>
</div>
<a id="aacaaa449af42b672227ce6606347a066" name="aacaaa449af42b672227ce6606347a066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaaa449af42b672227ce6606347a066">&#9670;&#160;</a></span>projectionConstruction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstruction </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a></td>          <td class="paramname"><span class="paramname"><em>projType</em></span><span class="paramdefsep"> = </span><span class="paramdefval">LLLPROJ</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In this version, the construction method is passed as a parameter. </p>
<p>The default is LLL. In the triangular case, a temporary matrix is created internally. </p>

</div>
</div>
<a id="a33e21410fcd60b6dc1a9bf1ac58ad029" name="a33e21410fcd60b6dc1a9bf1ac58ad029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e21410fcd60b6dc1a9bf1ac58ad029">&#9670;&#160;</a></span>projectionConstructionLLL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionLLL </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a basis for the projection <code>proj</code> of the lattice with basis <code>inBasis</code>, using <code>LLLBasisConstruction</code>, and returns it in <code>projBasis</code>. </p>
<p>This returned basis is not triangular in general. Its dimension will be the number of coordinates in <code>proj</code>. The matrix <code>projBasis</code> must have enough columns to hold it and at least as many rows as the number of rows that we use from <code>inBasis</code>. When <code>r &gt; 0</code>, only the first <code>r</code> rows of the matrix <code>inBasis</code> are used, otherwise we use all rows of that matrix. This <code>r</code> should normally be the true dimension <code>dim</code> of that basis, which is often smaller than the size <code>maxDim</code> of the <code>IntMat</code> object that contains the basis. The square Euclidean lengths of the basis vectors are returned in the array <code>sqlen</code> when the latter is given. </p>

</div>
</div>
<a id="afab54fa69b7e88d66cbcc2f7568674ac" name="afab54fa69b7e88d66cbcc2f7568674ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab54fa69b7e88d66cbcc2f7568674ac">&#9670;&#160;</a></span>projectionConstructionUpperTri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>genTemp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>projectionConstructionLLL</code>, but the construction is made using <code>upperTriangularBasis</code>, so the returned basis is upper triangular. </p>
<p>When <code>r &gt; 0</code>, only the first <code>r</code> rows of the matrix <code>inBasis</code> are actually used, otherwise we use all rows of that matrix. In the first version, we pass a matrix <code>genTemp</code> that will be used to store the generating vectors of the projection before making the triangularization. The two matrices <code>projBasis</code> and <code>genTemp</code> must have enough columns to hold the projection and at least as many rows as the number of rows that we use from <code>inBasis</code>. We pass <code>genTemp</code> as a parameter to avoid the internal creation of a new matrix each time, in case we call this function several times. Its contents will be modified. In the second version, this matrix is not passed and a temporary one is created internally, which may add a bit of overhead. </p>

</div>
</div>
<a id="aac6373857de656ccfeb0972950b2986d" name="aac6373857de656ccfeb0972950b2986d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6373857de656ccfeb0972950b2986d">&#9670;&#160;</a></span>projectMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectMatrix </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function overwrites the first <code>r</code> rows of matrix 'out' by a matrix formed by the first <code>r</code> rows of the c columns of matrix <code>in</code> that are specified by <code>proj</code>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <code>proj</code>. </p>
<p>Only the first c columns of the first <code>r</code> rows are overwritten; the other entries are left unchanged. If <code>r = 0</code>, then all the rows of matrix <code>in</code> are taken. When <code>in</code> is a basis, <code>r</code> will usually be the dimension of that basis and <code>c</code> will be smaller. The dimensions of the matrices <code>in</code> and <code>out</code> are always left unchanged. The dimensions of <code>out</code> are assumed to be large enough. After the call, the matrix <code>out</code> will then contain a set of generating vectors for the projection <code>proj</code>. The matrices <code>in</code> and <code>out</code> must be different IntMat objects, otherwise the program halts with an error message. </p>

</div>
</div>
<a id="aa9056e4da6e74d83c6061650caf9e59f" name="aa9056e4da6e74d83c6061650caf9e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9056e4da6e74d83c6061650caf9e59f">&#9670;&#160;</a></span>Quotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>a/b</code>, truncates the fractional part and puts the result in q. </p>
<p>This function is overloaded to work as specified on NTL::ZZ integers. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
<p class="reference">Referenced by <a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide()</a>, <a class="el" href="../../d0/d8f/classLatMRG_1_1LCGLattice.html#ac59d4ab2b5971f4c7e6ae9861078c26e">LatMRG::LCGLattice&lt; Int, Real &gt;::incDim()</a>, and <a class="el" href="../../df/d81/classLatMRG_1_1Modulus.html#a8eb0ea4721f0b424ca021c900f79c57e">LatMRG::Modulus&lt; Int &gt;::reduceM()</a>.</p>

</div>
</div>
<a id="a3fdad6592203c9b83f2ef7caf7b8441f" name="a3fdad6592203c9b83f2ef7caf7b8441f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdad6592203c9b83f2ef7caf7b8441f">&#9670;&#160;</a></span>RandBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t LatticeTester::RandBits </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer. </p>
<p>It is imperative that \(1 \leq s \leq 64\) because the RNG is 64 bits wide. </p>

</div>
</div>
<a id="a3f7dd0225a074e885d6d54916757fcec" name="a3f7dd0225a074e885d6d54916757fcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7dd0225a074e885d6d54916757fcec">&#9670;&#160;</a></span>RandInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t LatticeTester::RandInt </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a uniform pseudo-random integer in \([i, j]\). </p>
<p>Note that the numbers \(i\) and \(j\) are part of the possible output. It is important that \(i &lt; j\) because the underlying arithmetic uses unsigned integers to store j-i+1 and that will be undefined behavior. </p>

</div>
</div>
<a id="abba336d3a5abb22b8367ddfa37a713e4" name="abba336d3a5abb22b8367ddfa37a713e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba336d3a5abb22b8367ddfa37a713e4">&#9670;&#160;</a></span>RandU01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::RandU01 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number in \([0, 1)\). </p>
<p>The number will have 53 pseudo-random bits. </p>

</div>
</div>
<a id="a63dafe7fe191c17bcb7c178149db6570" name="a63dafe7fe191c17bcb7c178149db6570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dafe7fe191c17bcb7c178149db6570">&#9670;&#160;</a></span>redLLL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation of the LLL reduction algorithm with factor <code>delta</code>, presented in <b>[mSCH91a]</b> (see also <b>[iLEC22l]</b>). </p>
<p>The reduction is applied to the first <code>dim</code> basis vectors and coordinates when <code>dim &gt; 0</code>, and to the entire basis (all vectors) when <code>dim=0</code>. In the former case, the transformations are not applied to all the columns, so we will no longer have a consistent basis for the original lattice if it had more than <code>dim</code> dimensions. To recover a basis for the full lattice in this case, we may save it before calling this function, or rebuild it.</p>
<p>This function always uses the Euclidean norm. The factor <code>delta</code> must be in [1/2, 1). The closer it is to 1, the more the basis is reduced, in the sense that the LLL algorithm will enforce tighter conditions on the basis. The returned basis always has its shortest vector in first place. The vector pointed by <code>sqlen</code> (if given) will contain the square lengths of the basis vectors. To recover these values in a <code>Vec&lt;double&gt; v</code> one can pass <code>&amp;v</code> to the function. The parameter <code>precision</code> specifies the precision of the floating point numbers that the algorithm will use. <code>EnumTypes.h</code> provides a list of the possible values, and their description is done in the module <code>LLL</code> of <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>. </p>

<p class="reference">References <a class="el" href="#a852fa8fe7dda3213afd5db3e65caa43c">myExit()</a>.</p>

</div>
</div>
<a id="a5830bb0fae462b5e85c8eeb1c126a647" name="a5830bb0fae462b5e85c8eeb1c126a647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5830bb0fae462b5e85c8eeb1c126a647">&#9670;&#160;</a></span>redLLLExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLLExact </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This static function implements an exact algorithm from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> to perform the original LLL reduction. </p>
<p>This is slower than <code>redLLLNTL</code>, but more accurate. It does not take the <code>dim</code> and <code>sqlen</code> parameters (for now). </p>

<p class="reference">References <a class="el" href="#a852fa8fe7dda3213afd5db3e65caa43c">myExit()</a>.</p>

</div>
</div>
<a id="a15f15a1453b578cb49b2e3deda5a200d" name="a15f15a1453b578cb49b2e3deda5a200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f15a1453b578cb49b2e3deda5a200d">&#9670;&#160;</a></span>Round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::Round </td>
          <td>(</td>
          <td class="paramtype">Real</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of x rounded to the NEAREST integer value. </p>
<p>(This does not truncate the integer value as is usual in computer arithmetic.) </p>

</div>
</div>
<a id="a1a68bc6b1e81a03d09ea07fa9efed658" name="a1a68bc6b1e81a03d09ea07fa9efed658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a68bc6b1e81a03d09ea07fa9efed658">&#9670;&#160;</a></span>SetSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetSeed </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed of the generator. </p>
<p>Because of the constraints on the state, <code>seed</code> has to be \( &gt; 2\). If this is never called, a default seed will be used. </p>

</div>
</div>
<a id="a2a728d56ee563237fe943ebd333fa3f5" name="a2a728d56ee563237fe943ebd333fa3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a728d56ee563237fe943ebd333fa3f5">&#9670;&#160;</a></span>SetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetValue </td>
          <td>(</td>
          <td class="paramtype">Real *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <code>d</code> components of <code>A</code> to 0. </p>
<p>Sets the first <code>d</code> components of <code>A</code> to the value <code>x</code>. </p>

</div>
</div>
<a id="a59016f13e4470ad17683b1cfeb70153c" name="a59016f13e4470ad17683b1cfeb70153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59016f13e4470ad17683b1cfeb70153c">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sign of <code>x</code>. </p>
<p>The sign is 1 if <code>x&gt;0</code>, 0 if <code>x==0</code> and -1 if <code>x&lt;0</code>. </p>

</div>
</div>
<a id="ad4d16fed8fda92252dc423db28136932" name="ad4d16fed8fda92252dc423db28136932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d16fed8fda92252dc423db28136932">&#9670;&#160;</a></span>swap9()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::swap9 </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes references to two variables of a generic type and swaps their content. </p>
<p>This uses the assignment operator, so it might not always work well if this operator's implementation is not thorough. </p>

<p class="reference">Referenced by <a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide()</a>, <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#ac9eaee4237af0224f3239364fa63a181">LatticeTester::IntLattice&lt; Int, Real &gt;::permute()</a>, and <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a82d8ec2cbb813106f29d9e4bd4a8b647">LatticeTester::IntLattice&lt; Int, Real &gt;::permuteDual()</a>.</p>

</div>
</div>
<a id="a6c4c9e2b77c4dc22c74401738c15c8b8" name="a6c4c9e2b77c4dc22c74401738c15c8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4c9e2b77c4dc22c74401738c15c8b8">&#9670;&#160;</a></span>toStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStr </td>
          <td>(</td>
          <td class="paramtype">const MatT &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string that is a representation of <code>mat</code>. </p>
<p>This string represents the \(d1 \times d2\) submatrix of the first lines and columns of <code>mat</code>. </p>

</div>
</div>
<a id="ad18ba9347ad4166201654eb4ad5c6972" name="ad18ba9347ad4166201654eb4ad5c6972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18ba9347ad4166201654eb4ad5c6972">&#9670;&#160;</a></span>toString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing <code>A[c]</code> to <code>A[d-1]</code> formated as <code>[A[c]sep...sepA[d-1]]</code>. </p>
<p>In this string, components are separated by string <code>sep</code>. By default, <code>sep</code> is just a whitespace character. </p>

<p class="reference">Referenced by <a class="el" href="../../d9/d84/classLatMRG_1_1MRGComponent.html#afe8a90c6fdfb81611d2a7ee2a052dbb0">LatMRG::MRGComponent&lt; Int &gt;::toString()</a>, <a class="el" href="#a9c697e5d81b902cbb4283a21104ac62b">toString()</a>, <a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html#a70942711d3047d6e7f303d7834e86b73">LatMRG::MRGLattice&lt; Int, Real &gt;::toStringCoef()</a>, <a class="el" href="../../d9/d4e/classLatticeTester_1_1MRGLattice.html#a75e0a27ec0cf4bdfc129d1682d1e90b1">LatticeTester::MRGLattice&lt; Int, Real &gt;::toStringCoef()</a>, and <a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#ac61ecbccfe48180c53ce8aa7f5fe0839">LatticeTester::Rank1Lattice&lt; Int, Real &gt;::toStringCoef()</a>.</p>

</div>
</div>
<a id="a9c697e5d81b902cbb4283a21104ac62b" name="a9c697e5d81b902cbb4283a21104ac62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c697e5d81b902cbb4283a21104ac62b">&#9670;&#160;</a></span>toString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing the first <code>d</code> components of the vector <code>A</code> as a string. </p>
<p>Calls <code>toString(const Vect&amp;, int, int, const char*)</code>. </p>

<p class="reference">References <a class="el" href="#ad18ba9347ad4166201654eb4ad5c6972">toString()</a>.</p>

</div>
</div>
<a id="aaa2f58453cd5cd239b67d0eb92b3dadf" name="aaa2f58453cd5cd239b67d0eb92b3dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f58453cd5cd239b67d0eb92b3dadf">&#9670;&#160;</a></span>TransposeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::TransposeMatrix </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>mat2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <code>mat</code> and iteratively transforms it into an upper triangular lattice basis into the matrix <code>mat2</code>. </p>
<p><code>mat</code> and <code>mat2</code> have to have the same number of rows and the same number of columns. All the computations will be done modulo <code>mod</code>, which means that you must know the rescaling factor for the vector system to call this function. After the execution, <code>mat</code> will be a matrix containing irrelevant information and <code>mat2</code> will contain an upper triangular basis.</p>
<p>For more details please look at <b>[latTesterGide]</b>. This algorithm basically implements what is written in this guide. The matrix <code>mat</code> contains the set of vectors that is used and modified at each step to get a new vector from the basis. Lower triangularization </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li>
    <li class="footer">Generated on Fri Jul 18 2025 21:40:38 for LatMRG API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
