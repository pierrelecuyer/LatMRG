<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatMRG API Documentation: LatMain</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatMRG API Documentation<span id="projectnumber">&#160;unknown</span>
   </div>
   <div id="projectbrief">Tools to analyze the lattice structure of linear generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d13/LatMain.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">LatMain</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the main program for the lattice tests. Depending on the parameters in the data file, it runs either the spectral or the Beyer test and computes the figure of merit for the given lattice. The program reads the name of a data file without extension from the command line. The data file must have the extension <code>.dat</code>. The call then looks like </p><pre class="fragment"> LatMain &lt;LD, ZD, ZR&gt; lat1
</pre><p>Depending on the parameters in the data file, the results will be sent on the terminal or in a file with the same name as the data file, but with extension <code>.res</code>. In the above example, the results would be generated from the configuration of <code>lat1.dat</code> to either the command line or a file called <code>lat1.res</code>.</p>
<p>It is also possible de use this program on multiple files in one call: </p><pre class="fragment"> LatMain &lt;LD, ZD, ZR&gt; file1 file2 ...
</pre><p>Or even on complete directories, trying to execute on all files with the extension <code>.dat</code> in them. </p><pre class="fragment"> LatMain &lt;LD, ZD, ZR&gt; dir1 dir2 ...
</pre><p>All other files without extension <code>".dat"</code> in the directories will be disregarded. When calling on multiple files at once or on directories, the program will output in the same exact manner as if it had been called on each configuration file independently. Note that the program WILL CRASH and not complete the execution if it is called on a directory containing a file with extension <code>.dat</code> that is not a configuration for this program (such as configuration files for other <em><a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a></em> programs).</p>
<p>This program can run in 3 different modes depending on the number types you want to software to use. The type combo <code>ID</code> uses standard C++ 64-bits integers (<code>std::int64_t</code> and std::uint64_t) to represent integers and the <code>double</code> type to represent floating point numbers. This is useful to test the program with "toy" examples and should be (more than) "good enough" to test generators conceived with (up to) 32-bits computers in mind. The type combo <code>ZD</code> uses <code>NTL::ZZ</code> for arbitrary precision integer representation and <code>double</code> for floating point numbers. This types combination should cut it for pretty much every use case, as only the integer representation is critical to the software. Should you run into weird issues (that you suspect might come from division or inadequate vector length computing for example), it is also possible to trade the <code>double</code> type for <code>NTL::RR</code> as a floating point number representation, but it should not be necessary. For a more in depth comparison of those types, we redirect you to <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a></em> manual, and C++ and <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> documentation.</p>
<p>It is advised to choose the types with the least precision possible, because standard types usually perform their operations in hardware and lend much better efficiency and speed.</p>
<p>This program takes 3 different bits of information as an input: a test to compute a figure of merit with, a linear congruencial type random number generator and a list of dimensions on which to perform a projection. Let \(\mathcal{J}\) be the list of set specified as projections and \(m_I\) be the result of the test specified on the generator given as input on \(I \in \mathcal{J}\), then the main goal of this program is to compute a figure of merit of the form   </p><p class="formulaDsp">
\[
     M_\mathcal{J} = \min_{I\in \mathcal{J}} m_I.
\]
</p>
<p> This program will output the result of each single test \(m_I\) and the global figure of merit. This program is conceived as a way to perform in-depth testing of</p>
<p>We now proceed by presenting the format of the input file of <code>LatMain</code> and explain what each parameter is about. This also serves as a description of the range of operations <code>LatMain</code> is able to do. The input file must have the extension <code>.dat</code>. Lines whose first non-blank character is a <code>#</code> will be considered as comments and are dropped by the reader program. </p><pre class="fragment"> Test Normalizer
 Norm
 ReadGenFile [GenFile]
 J
 GenType                   // This section has to appear J times
 m                         //
 k                         //
 CoefCond [s k_1 ... k_s]  //
 a_1 ... a_k               //
 d
 td[0] td[1] ... td[d]
 DualFlag
 LatticeType
 LacGroupSize
 LacSpacing
 MaxNodesBB
 InvertFlag
 DetailFlag
 OutputForm
</pre> <center> <b>Data file format for LatMain</b> </center><dl>
<dt><code>Test Normalizer</code>: </dt>
<dd>The used to compute the figure of merit. It has to be either <b>BEYER</b>, in which case the program will build its figures of merit on the Beyer quotient, or <b>SPECTRAL</b>, for which the program will use the spectral test for the figure of merit. If <b>SPECTRAL</b> is selected, the field <code>Normalizer</code> must contain one of The lattice test can be one of <code>Spectral</code>, <code>Beyer</code> or <code>Palpha</code>. The normalizer depends on which lattice test is performed. For the <code>Spectral</code> test, it may be one of <code>BestLat</code>, <code>Laminated</code>, <code>Rogers</code>, <code>Minkowski</code> or <code>MinkL1</code>, otherwise it may be left blank.  </dd>
<dt><em>Norm</em>: </dt>
<dd>To measure the length of vectors. Can be <code>L1NORM</code> or <code>L2NORM</code>.  </dd>
<dt><em>ReadGenFile</em> &lt;<em>Genfile</em>&gt;: </dt>
<dd><code>boolean</code> and file name (without extension). When <em>ReadGenFile</em> is <code>false</code>, the search is made according to the values of the fields below. When <code>true</code>, the generators to be tested are those listed in the file &lt;<em>Genfile</em>&gt;<code>.gen</code>.  </dd>
<dt><em>J</em>: </dt>
<dd>Number of components in the combined generator.  </dd>
<dt><em>GenType</em>: </dt>
<dd><p class="startdd">Type of generator. For now, the possibilities are:</p>
<dl>
<dt><code>MRG</code> </dt>
<dd>means that this component is an MRG.  </dd>
<dt><code>MWC</code> </dt>
<dd>means that this component is a multiply-with-carry (MWC) generator. Each MWC generator is converted by the program to its corresponding LCG (see, e.g., <b>[rCOU97a]</b>, <b>[rLEC98a]</b>&thinsp;).  </dd>
<dt><code>KOROBOV</code>: </dt>
<dd>means that this component is a Korobov lattice.  </dd>
<dt><code>RANK1</code>: </dt>
<dd>means that this component is a rank 1 lattice.  </dd>
</dl>
</dd>
<dt><em>m, k</em>: </dt>
<dd>Modulus and order of the recurrence. Must be positive integers.  </dd>
<dt><em>CoefCond</em>&#160;&lt; \(s\) \(k_1\) \(k_2 \cdots k_s\)&gt;: </dt>
<dd><p class="startdd">Conditions on the coefficients. The possible cases are:</p>
<dl>
<dt><code>NonZero</code> \(s\) \({k_1}\) \({k_2}\) \(\cdots\) \({k_s}\): </dt>
<dd>all the coefficients \(a_j\) are 0, except for \(s\) of them: the non-zero coefficients are \(a_{k_1}\), \(a_{k_2}\), …, \(a_{k_s}\), and their values are given on the following line. For example, for a MRG of order \(k=10\), the line <code>"NonZero 4 2 5 8 10"</code> means that the vector of coefficients is  \(\mathbf{a} = (0, \alpha, 0, 0, \beta, 0, 0,
\gamma, 0, \delta)\) where \(\alpha, \beta, \gamma, \delta\) are the \(s\) non-zero coefficients given on the following line.  </dd>
<dt><code>Equal</code> \(s\) \({k_1}\) \({k_2}\) \(\cdots\) \({k_s}\): </dt>
<dd>The coefficients are equal by groups. There are \(s\) groups: the first group of \(k_1\) coefficients are all equal, the second group of \(k_2 - k_1\) coefficients are all equal, and so on until the last group of \((k_s - k_{s-1})\) coefficients. \(k_j\) is the vector index of the last element of group \(j\). For example, for a MRG of order \(k=10\), the line <code>"Equal 4 2 5 8 10"</code> will give a vector of coefficients of the form  \(\mathbf{a} =
(\alpha, \alpha, \beta, \beta, \beta, \gamma, \gamma, \gamma, \delta, \delta)\) where \(\alpha, \beta, \gamma, \delta\) are \(s\) coefficients given on the following line.  </dd>
<dt><code>NoCond</code>: </dt>
<dd>There is no condition on the coefficients and they are all given on the following line.  </dd>
</dl>
</dd>
<dt>\((a_1,a_2,…,a_k)\): </dt>
<dd>the vector of (integer) multipliers all given on one line.  </dd>
<dt><em>d</em>: </dt>
<dd>The number of kinds of projections. The standard case has \(d=1\) and the test will be run for all successive dimensions from <em>td[0] = MinDim</em> to <em>td[1] = MaxDim</em>.  </dd>
<dt><em>td[0]</em> &#160;<em>td[1]</em> …&#160;<em>td[d]</em>: </dt>
<dd>The test will be run for all successive dimensions from <em>td[0]</em> to <em>td[1]</em>, then for all 2-dimensional projections for dimensions up to <em>td[2]</em> (if \(d\ge2\)), for all 3-dimensional projections for dimensions up to <em>td[3]</em> (if \(d\ge3\)), …, and for all \(d\)-dimensional projections for dimensions up to <em>td[d]</em>. The simplest case has \(d=1\).  </dd>
<dt><em>Dual flag</em>: </dt>
<dd><code>true</code> if the dual lattice is analyzed; <code>false</code> for the primal lattice.  </dd>
<dt><em>LatticeType</em>: </dt>
<dd><p class="startdd">Indicates whether to analyze the lattice generated by all possible states, or a sublattice generated by the set of recurrent states or by a subcycle of the generator. The admissible values are <code>(Full, Recurrent, Orbit, PrimePower)</code>.</p>
<dl>
<dt><code>Full</code>: </dt>
<dd>The complete lattice, generated by all possible initial states, will be analyzed.  </dd>
<dt><code>Recurrent</code>: </dt>
<dd>If the (combined) generator has transient states, then the lattice analyzed will be the sublattice generated by the set of recurrent states.  </dd>
<dt><code>Orbit</code>: </dt>
<dd>The grid generated by the (forward) orbit of a state of the (combined) generator is analyzed. This state is specified as follows. On the following \(J\) lines, the initial state for each component must be given. This is an integer vector with a number of components equal to the order of the component.  </dd>
<dt><code>PrimePower</code>: </dt>
<dd>In the case where some component is an MLCG whose modulus is a power of a prime \(p\), then the states visited over a single orbit (subcycle) of that component generate a sublattice (when \(a \equiv1 \pmod p\)) or belong to the union of \(p-1\) sublattices (otherwise). If <em>LatticeType</em> takes this value, if a component is an MLCG ( \(k=1\)), and if the modulus of that MLCG is given in the data file in the form (b):  \((x y
z)\) with \(z=0\) and \(x\) prime, then what is analyzed is one of those sublattices. This is done by dividing the modulus by the appropriate power of \(p\), as described in <b>[rLEC94e]</b>&thinsp;. For example, if \(p=2\) and \(a \mod8 = 5\), then the modulus is divided by 4 as in <b>[rFIS90a]</b>, <b>[rKNU81a]</b>&thinsp;.  </dd>
</dl>
</dd>
<dt><em>LacGroupSize &#160;LacSpacing</em>: </dt>
<dd>These data fields are positive integers, used to introduce lacunary indices. If the respective values are \(s\) and \(d\), then we will analyze the lattice structure of vectors of the form  \((u_{i+1}, …,
u_{i+s}, u_{i+d+1},…, u_{i+d+s}, u_{i+2d+1},…, u_{i+2d+s}, …)\), formed by groups of \(s\) successive values, taken \(d\) values apart. To analyze vectors of successive values (as usual), take \(s=d=1\) or \(s\) larger or equal to <em>MaxDim</em>. To analyze lacunary indices that are not evenly spaced, put \(s = -t\) where <em> \(t=\)MaxDim</em> and then, on the \(t\) lines that follow, give the \(t\) lacunary indices \(i_1,…,i_t\), which are interpreted as in Section.  </dd>
<dt><em>MaxNodesBB</em>: </dt>
<dd>An integer giving the maximum number of nodes to be examined in any given branch-and-bound procedure when computing \(d_t\) or \(q_t\). When that value is exceeded, the branch-and-bound is stopped and the generator is rejected. The number of generators rejected for that reason is given in the results. A small value of <em>MaxNodesBB</em> will make the program run faster (sometimes much faster), permitting to examine more generators, but will increase the chances of rejecting good generators.  </dd>
<dt><em>Invert flag</em>: </dt>
<dd>If <code>true</code>, the inverse of the length of the shortest vector will be printed in the results, otherwise the length itself is printed.  </dd>
<dt><em>Detail flag</em>: </dt>
<dd>The default value of the flag is 0. If it is \(&gt;0\), extra details are printed in the results. If the flag is 1, the shortest vector of the basis is printed. If the flag is 2, all the vectors of the final basis are printed. If the flag is 3, all the vectors of the initial primal and dual bases are printed.  </dd>
<dt><em>Output Form</em>: </dt>
<dd><p class="startdd">Selects on which output the results will be written. The possible values are <code>(Terminal, RES, TEX)</code>. Lowercases are also allowed.</p>
<dl>
<dt><code>Terminal</code>: </dt>
<dd>the results will be written on the terminal screen.  </dd>
<dt><code>Res</code>: </dt>
<dd>the results are sent to a file with the same name as the data file, but with extension <code>.res</code>.  </dd>
<dt><code>Tex</code>: </dt>
<dd>the results are written in a file intended for LaTeX, with extension <code>.tex</code>.  </dd>
</dl>
</dd>
</dl>
<p>The form of the data file for the Palpha test must be as shown in Fig.</p>
<center> <div class="LatSoft-fbox"><div class="LatSoft-parbox"> <table class="LatSoft-table">
<tr>
<td colspan="3" class="l"># This is a comment line </td></tr>
<tr>
<td class="l"><code>PALPHA</code> </td><td class="l"></td><td class="l">must always be there </td></tr>
<tr>
<td class="l"><em>calcType</em> </td><td class="l"></td><td class="l"></td></tr>
<tr>
<td class="l"><code>LCG</code> </td><td class="l"></td><td class="l">only LCG are possible for now </td></tr>
<tr>
<td class="l">\(m\) </td><td class="l"></td><td class="l">number of points </td></tr>
<tr>
<td class="l">\(a\) </td><td class="l"></td><td class="l">multiplier </td></tr>
<tr>
<td class="l">\(d\) </td><td class="l"></td><td class="l">= 1 for now </td></tr>
<tr>
<td class="l"><em>minDim</em> </td><td class="l"><em>maxDim</em> </td><td class="l">two integers </td></tr>
<tr>
<td class="l"><em>primeM</em> </td><td class="l"><em>verifyM</em> </td><td class="l">two booleans </td></tr>
<tr>
<td class="l"><em>maxPeriod</em> </td><td class="l"><em>verifyP</em> </td><td class="l">two booleans </td></tr>
<tr>
<td class="l"><em>alpha</em> </td><td class="l"></td><td class="l">\(\alpha\), an integer </td></tr>
<tr>
<td class="l"><em>seed</em> </td><td class="l"></td><td class="l">seed of the LCG, an integer </td></tr>
<tr>
<td class="l">\(\beta_0, \beta_1\), \(…, \beta_s\) </td><td class="l"></td><td class="l">\(s\) = <em>maxDim</em> </td></tr>
<tr>
<td class="l"><em>outputForm</em> </td><td class="l"></td><td class="l"><code>terminal</code>, <code>res</code> or <code>tex</code>  </td></tr>
</table>
</div></div> <center><a class="anchor" id="REF__LatMain_palpha_data"></a>Data file format for the \(P_{\alpha}\) test.</center> </center><p>Lines whose first non-blank character is a <code>#</code> are comments, and are dropped by the reader program. The file must contain the following parameters in that order:</p>
<dl>
<dt><code>PALPHA</code>: </dt>
<dd>must always be there literally. This indicates to the program that the parameters to be read are for the \(P_{\alpha}\) test, instead of the spectral or Beyer tests.  </dd>
<dt><em>calcType</em>: </dt>
<dd>must be one of <code>PAL</code>, <code>BAL</code>, or <code>NORMPAL</code>. See the description of these cases in the definition of LatCommon::CalcType.  </dd>
<dt><code>LCG</code>: </dt>
<dd>must always be there literally.  </dd>
<dt>\(m\): </dt>
<dd>the number of points of the point set or the modulus of congruence of the LCG.  </dd>
<dt>\(a\): </dt>
<dd>the multiplier of the LCG or of the Korobov lattice. Restriction:  \(a
\in\{1, 2, …, m-1\}\).  </dd>
<dt>\(d\): </dt>
<dd>The number of kinds of projections. Always \(d=1\) for now.  </dd>
<dt><em>minDim</em> and <em>maxDim</em>: </dt>
<dd>the test will be done in all dimensions \(s\) such that <em>minDim</em> \(\le s \le\) <em>maxDim</em>.  </dd>
<dt><em>primeM</em> and <em>verifyM</em>: </dt>
<dd>if <em>primeM</em> is <code>true</code>, the program considers that \(m\) is a prime number; if <code>false</code>, \(m\) is assumed not prime. If <em>verifyM</em> is <code>true</code>, the program will verify that \(m\) is effectively prime and reset <em>primeM</em> to its correct value. If <em>verifyM</em> is <code>false</code>, the program will not verify the primality of \(m\); in that case, it is the responsibility of the user to set the right value for <em>primeM</em>.  </dd>
<dt><em>maxPeriod</em> and <em>verifyP</em>: </dt>
<dd>if <em>maxPeriod</em> is <code>true</code>, the program considers that the LCG has maximal period; if <code>false</code>, the LCG is assumed not to have maximal period. If <em>verifyP</em> is <code>true</code>, the program will verify that the LCG has maximal period and will reset <em>maxPeriod</em> to its correct value. If <em>verifyP</em> is <code>false</code>, the program will not verify that the LCG has maximal period; in that case, it is the responsibility of the user to set the right value for <em>maxPeriod</em>.  </dd>
<dt><em>alpha</em>: </dt>
<dd>the value of \(\alpha\). Must be one of \(\{2, 4, 6, 8\}\).  </dd>
<dt><em>seed</em>: </dt>
<dd>The starting state of the LCG. Must be one of \(\{1, 2, …, m-1\}\).  </dd>
<dt>\(\beta_0, \beta_1\), \(…, \beta_s\): </dt>
<dd>\(s+1\) real numbers on a line where \(s =\) <em>maxDim</em>. They are the weights \(\beta_j\).  </dd>
<dt><em>outputForm</em>: </dt>
<dd>can take the values <code>terminal</code> (the output will be sent on the terminal), <code>res</code> (the output will be written in plain text format in a file), or <code>tex</code> (the output will be written in LaTeX format in a file). In the last two cases, the name of the output file will always have the same stem as the data file name. For example, if the data file is named <code>alp1.dat</code>, then the output file will be called <code>alp1.res</code> and <code>alp1.tex</code>, respectively.  </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jul 18 2025 21:40:38 for LatMRG API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
