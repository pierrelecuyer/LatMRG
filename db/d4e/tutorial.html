<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatMRG API Documentation: Tutorial and Library Usage</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatMRG API Documentation<span id="projectnumber">&#160;unknown</span>
   </div>
   <div id="projectbrief">Tools to analyze the lattice structure of linear generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d4e/tutorial.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial and Library Usage</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Most use cases of <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> should be covered by the executable program, but <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> is also distributed as a library to easily expand its functions. You might want to:</p><ul>
<li>Perform tests in a sequence or on subsets that we do not provide</li>
<li>Test unimplemented forms of generators</li>
<li>Implement new tests and figures of merit With some knowledge of the C++ programming language, it is possible to both expand the functionnalities of <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> and to use it as a library to write your own programs.</li>
</ul>
<p>This section first presents the main classes of the library and how to expand them. We then provide a few programming guidelines to expand the software provided in <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a>. Finally, we present a few examples of its usage as a library.</p>
<h1><a class="anchor" id="classes_list"></a>
Classes of LatMRG</h1>
<p>We present the main classes of <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a>. This will not cover the details of those classes, which is available in their respective documentation.</p>
<h2><a class="anchor" id="classes_list_types"></a>
Types in LatMRG</h2>
<p>If you browse the source code, you will notice that a lot of classes are template classes. This is because the arithmetic can be done with a variable level of precision depending on the usage. Template classes feature readily available template instantiation with relevant types and types combinations in the library.</p>
<p>For integers, types we use are fixed width 64 bits integers <code>int64_t</code> and the arbitrary precision integers of <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> <code>ZZ</code>. For floating point numbers, the template parameters types can be <code>double</code> or <code>RR</code> from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>. Choosing standard types <code>int64_t</code> and <code>double</code> makes the program perform much faster because of the arithmetic. But they have a limited precision. This is specially important for integers: lattices basis need to be stored exactly for the program to work properly. If you think you might need to store a number greater than <code>2^63-1</code>, it is best to use arbitrary precision integers.</p>
<p>This topic is discussed more in length latter.</p>
<h2><a class="anchor" id="classes_list_mrg"></a>
MRG Representation</h2>
<p>The most important feature of <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> is its capacity to represent MRG random number generators and their lattices. The library features two different classes in this regard, depending on the use case.</p>
<p><code><a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html" title="This subclass of IntLatticeExt defines an MRG lattice and is similar to Rank1Lattice,...">LatMRG::MRGLattice</a></code> is the main class to do so. This class allows the the storage of a MRG's parameters (a vector of multipliers, a modulo and an order) and also the reprensentation of a lattice basis for this generator. This class also has an overridable interface to build the basis of the generator lattice for an arbitrary dimension.</p>
<p>The other class to store MRG generators is the <code><a class="el" href="../../d9/d84/classLatMRG_1_1MRGComponent.html" title="This class offers tools to verify if an MRG recurrence or order  modulo , of the form.">LatMRG::MRGComponent</a></code> class. Just like <code>MRGLattice</code>, this class stores the components of a MRG generator, but it cannot store a lattice basis. This is useful when you want to avoid having to store a heavy object only for generators componenets. This class also bundles a few utility function that can, for example, check if the components stored are that of a full period MRG.</p>
<p><code>MRGLattice</code> is used as the base class for other MRG generator types classes. Combined generators represented in <code><a class="el" href="../../de/d2b/classLatMRG_1_1ComboLattice.html" title="This class represents a combined MRG.">LatMRG::ComboLattice</a></code>, MWC generators in <code>LatMRG::MWCLattice</code> and <code><a class="el" href="../../d1/d07/classLatMRG_1_1AWCSWBLattice.html" title="This class represents the lattice associated with either an AWC or a SWB random number generator.">LatMRG::AWCSWBLattice</a></code> and even MMRG generators in <code><a class="el" href="../../da/d2c/classLatMRG_1_1MMRGLattice.html">LatMRG::MMRGLattice</a></code>. Since most generators have an equivalence with MRG, it is practical to just define them with a constructor that initializes the underlying <code>MRGLattice</code> correctly. For example, the next few lines of code (and a few more declaration in the class body) are what initializes a <code>MWCLattice</code> with     </p><p class="formulaDsp">
\begin{align}
      x_n &amp; = (e_1 x_{n-1} + \cdots + e_k x_{n-k} + c_{n-1})d\ \mathrm{mod} \ b, \\
      c_n &amp; = \lfloor (e_0 x_n + e_1 x_{n-1} + \cdots + e_k x_{n-k} + c_{n-1} )/b \rfloor, \\
      u_n &amp; = \sum_{i=1}^\infty x_{n+i-1} b^{-i}.
   \end{align}
</p>
<p> The resulting object can then be used in any function working on <code>MRGLattice</code>s seamlessly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Int&gt;</div>
<div class="line">  Int LCGMod(<span class="keyword">const</span> Int&amp; b, <span class="keyword">const</span> NTL::vector&lt;Int&gt;&amp; e){</div>
<div class="line">    Int m(0);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;= e.length(); i++) {</div>
<div class="line">      m += e[i] * <a class="code hl_function" href="../../d2/d5a/namespaceNTL.html#a369678174d23f9f3b894bbcb332ada72">NTL::power</a>(b, i);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> m;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Int&gt;</div>
<div class="line">  NTL::vector&lt;Int&gt; <a class="code hl_function" href="../../da/d7a/namespaceMWCEquiv.html#a709bd0cc84db0a4047c944dd58c5f6ca">LCGCoeff</a>(<span class="keyword">const</span> Int&amp; b, <span class="keyword">const</span> NTL::vector&lt;Int&gt;&amp; e){</div>
<div class="line">    Int mult = <a class="code hl_function" href="../../da/d7a/namespaceMWCEquiv.html#a96cce35d6890b76a536c5270bae57061">LCGMod</a>(b,e);</div>
<div class="line">    std::cout &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    Int a = NTL::InvMod(b, mult);</div>
<div class="line">    NTL::vector&lt;Int&gt; coeff;</div>
<div class="line">    coeff.SetLength(2);</div>
<div class="line">    coeff[1] = a;</div>
<div class="line">    <span class="keywordflow">return</span> coeff;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Int, <span class="keyword">typename</span> Dbl&gt;</div>
<div class="line">  MWCLattice&lt;Int, Dbl&gt;::MWCLattice(<span class="keyword">const</span> Int &amp; b, <span class="keyword">const</span> IntVec &amp; e, <span class="keywordtype">int</span> k):</div>
<div class="line">    MRGLattice&lt;Int, Dbl&gt;(<a class="code hl_function" href="../../da/d7a/namespaceMWCEquiv.html#a96cce35d6890b76a536c5270bae57061">LCGMod</a>(b, e), <a class="code hl_function" href="../../da/d7a/namespaceMWCEquiv.html#a709bd0cc84db0a4047c944dd58c5f6ca">LCGCoeff</a>(b,e), 1, 1, FULL)</div>
<div class="line">{</div>
<div class="line">  m_MWCmod = b;</div>
<div class="line">  m_MWCorder = k;</div>
<div class="line">  m_eCoef.SetLength(k+1);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k+1; i++)</div>
<div class="line">    m_eCoef[i] = e[i];</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMWCEquiv_html_a709bd0cc84db0a4047c944dd58c5f6ca"><div class="ttname"><a href="../../da/d7a/namespaceMWCEquiv.html#a709bd0cc84db0a4047c944dd58c5f6ca">MWCEquiv::LCGCoeff</a></div><div class="ttdeci">NTL::vector&lt; Int &gt; LCGCoeff(const Int &amp;b, const NTL::vector&lt; Int &gt; &amp;e)</div><div class="ttdoc">Returns the coefficient a of the equivalent LCG for a MWC with coefficients in e and modulo b.</div><div class="ttdef"><b>Definition</b> MWCComponent.h:39</div></div>
<div class="ttc" id="anamespaceMWCEquiv_html_a96cce35d6890b76a536c5270bae57061"><div class="ttname"><a href="../../da/d7a/namespaceMWCEquiv.html#a96cce35d6890b76a536c5270bae57061">MWCEquiv::LCGMod</a></div><div class="ttdeci">Int LCGMod(const Int &amp;b, const NTL::vector&lt; Int &gt; &amp;e)</div><div class="ttdoc">Returns the modulo for an MWC with coefficients in e and modulo b.</div><div class="ttdef"><b>Definition</b> MWCComponent.h:24</div></div>
<div class="ttc" id="anamespaceNTL_html_a369678174d23f9f3b894bbcb332ada72"><div class="ttname"><a href="../../d2/d5a/namespaceNTL.html#a369678174d23f9f3b894bbcb332ada72">NTL::power</a></div><div class="ttdeci">std::int64_t power(std::int64_t p, std::int64_t i)</div><div class="ttdoc">Returns .</div><div class="ttdef"><b>Definition</b> NTLWrap.h:194</div></div>
</div><!-- fragment --><h2><a class="anchor" id="classes_list_tests"></a>
Testing and Reducing Lattices</h2>
<p>Most of the reduction functions available in <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> come from the <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> library. By using this library, it is possible to</p><ul>
<li>Compute the dual of an arbitrary basis</li>
<li>Perform BKZ, LLL and pairwise reduction of a lattice</li>
<li>Find the shortest non-zero vector in a lattice</li>
<li>Normalize the length of a short lattice vector</li>
</ul>
<p><a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> mainly implements two things, buiding up on <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a></p><ul>
<li>Projections sets, in a way that is relevant to testing a random number generator</li>
<li>Figures of Merit computations based on the shortest vector length or on the spectral test.</li>
</ul>
<p><code>LatMRG::Projections</code> is the class representing projections. It can be considered as a set \(\mathcal{I}\) of sets of indices and can be iterated over to obtain those sets of indices. Once objects of this class have been initialized, they can be used as iterators. This pairs with the <code>buildProjection</code> method inherited from <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> in <code>MRGLattice</code>. </p><div class="fragment"><div class="line">Projections proj(a,b,c);</div>
<div class="line">MRGLattice lat(m, a, n, k, latt);</div>
<div class="line">lat.buildBasis(n);</div>
<div class="line"><span class="keywordflow">while</span>(!proj-&gt;end()) {</div>
<div class="line"> <a class="code hl_class" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">LatticeTester::IntLattice</a> proj_lat;</div>
<div class="line"> lat.<a class="code hl_function" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a7c8c732f3bd7191e6d3d59649c0cd70f">buildProjection</a>(&amp;proj_lat, proj-&gt;next());</div>
<div class="line"> ...</div>
<div class="line">}</div>
<div class="ttc" id="aclassLatticeTester_1_1IntLattice_html"><div class="ttname"><a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">LatticeTester::IntLattice</a></div><div class="ttdoc">An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.</div><div class="ttdef"><b>Definition</b> IntLattice.h:83</div></div>
<div class="ttc" id="aclassLatticeTester_1_1IntLattice_html_a7c8c732f3bd7191e6d3d59649c0cd70f"><div class="ttname"><a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a7c8c732f3bd7191e6d3d59649c0cd70f">LatticeTester::IntLattice::buildProjection</a></div><div class="ttdeci">virtual void buildProjection(IntLattice&lt; Int, Real &gt; &amp;projLattice, const Coordinates &amp;proj)</div><div class="ttdoc">Builds a basis for the projection of the present lattice over the set of coordinates determined by pr...</div><div class="ttdef"><b>Definition</b> IntLattice.h:644</div></div>
</div><!-- fragment --><p>The <code>Test.h</code> file provides with functions that wrap <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> to either reduce a lattice or compute a form on merit on it. Once <code>MRGLattice</code> objects have been initialized, you simply need to build the lattice basis for different projections and call functions from this file on them.</p>
<h1><a class="anchor" id="program"></a>
Programming LatMRG</h1>
<p>In this section, we will present how to use <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> as a library and provide guidelines on how to expand the software.</p>
<h2><a class="anchor" id="program_types"></a>
Working with types</h2>
<p>The first thing anyone programming with <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> should know, is that <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> HAS TO perform on different types depending on the use case. Therefore, when programming new functions in <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> it is necessary to make sure that they are agnostic the possible types that might be used by the different <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> objects. Currently <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> can use <code>ZZ</code> from the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> library, as well as fixed width <code>int64_t</code> integers to represent the generators and their basis. It can also represent floating point numbers with both <code>double</code> and <code>RR</code> types. Note that there is one cavehat to the previous statements: the BKZ reduction method (in <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a>) requires that integers are of the <code>ZZ</code> type. This is because we did not implement the BKZ reduction and use the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> version instead. This version does not operate on <code>long</code> integers.</p>
<p>To work around this problem, <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> uses templates for most classes. This can feel problematic since these templates are not intended to work with most types ut only a few specific ones. This is mainly meant to reduce code duplication, but also gives us the flexibility to eventually change <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> for another library and not have to rewrite most of our code base. This is also intended to modify the old version of <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> that used compile time flags to determine the types.</p>
<p>Template classes in the software look like this: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Integ, <span class="keyword">typename</span> Float&gt; <span class="keyword">class </span>LatMRGClass {</div>
<div class="line">  <span class="keyword">typedef</span> Integ Int;</div>
<div class="line">  <span class="keyword">typedef</span> Float Dbl;</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>LatMRGClass&lt;std::int64_t, double&gt;;</div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>LatMRGClass&lt;NTL::ZZ, double&gt;;</div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>LatMRGClass&lt;NTL::ZZ, NTL::RR&gt;;</div>
</div><!-- fragment --><p> The first thing to note are the <code>typedef</code>s. Having them means that it is possible to interract with the class and its types and still write types agnostic code by referring to <code>typename LatMRGClass::Int</code>. The other thing to note is that the library instanciates all its templated classes with the types we support. This is meant to reduce compile time when using the library and helps verify that supported types works.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If you manipulate integers that are bigger than <code>2^32</code>, the result of a multiplication can overflow. Multiplications will occur when building a lattice basis.</dd></dl>
<h2><a class="anchor" id="program_creating"></a>
Adding new types of generators</h2>
<p>Although it shouldn't be necessary to add new types of generators in the the software, it is possible that some users would want to include classes to represent specific parameter combinations for certain generator kinds and specialize the lattice construction for those. For all its operation on generators, <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> interracts with the base class <code>MRGLattice</code>. This class inherits from <code>IntLattice</code> in <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> and has quite a few functions that can be specialized in subclasses.</p>
<p>To specialize the basis construction, all subclasses for MRGLattice can reimplement the virtual methods <code>buildBasis(int)</code> and <code>incDim()</code>. The first method is intended to build a basis of dimension specified as argument, and the second one increases the basis dimension by one.</p>
<p>The other main function you might want to specialize in <code>MRGLattice</code> is the <code>toString()</code> function. This function returns a string that describes the generator represented by the lattice. There curently is no standard format to be returned by this method and it is left to the user discretion to choose what information is important. For example, for <code>MRGLattice</code>, this only prints the coefficients as </p><div class="fragment"><div class="line">a1 = x1</div>
<div class="line">...</div>
<div class="line">ak = xk</div>
</div><!-- fragment --><p> but it could be possible to create a class that represents a MRG with specific choice of coefficients. For example, if the coefficients are chosen as the sum of powers of primes <code>p1</code>, ..., <code>pj</code> one could change the method to print <code>a1 = x1 = p1^e1 + ... + pj^ej</code>.</p>
<h2><a class="anchor" id="program_expanding"></a>
Expanding the executable</h2>
<p>One of the reasons you might want to use <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> is to search for generators. The main tool <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> provides for this is its executable, but this means expanding the search functionnality of the software is not as easy as writing a function to generate vectors \((a_1, \ldots, a_k)\) given a strategy. There are two options to search for custom new generators with <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a>.</p>
<p>First, you can write some sort of script using the library functions to handle the lattices and make the computations. In that case, most, if not all, the logic would have to be written by you. If you want a customizable program, this might get complicated for what should be a "simple" task.</p>
<p>Your other option is to modify the executable of <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> to search generators as you need them and apply tests as it can already do. The intention of the executable is to be robust to different types specifications and easily enable users to modify it. We focus on this option here.</p>
<p>To search for generators, the program calls the following function: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lat&gt; <span class="keyword">struct </span>SeekMain {</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Lat::Int Int;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Lat::Dbl Dbl;</div>
<div class="line">  <span class="keyword">typedef</span> NTL::vector&lt;Int&gt; IntVec;</div>
<div class="line">  <span class="keyword">typedef</span> NTL::matrix&lt;Int&gt; IntMat;</div>
<div class="line"> </div>
<div class="line">  ConfigSeek&lt;Int, Dbl&gt; conf;</div>
<div class="line"> </div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> Seek (Lat* (*nextGenerator)(ConfigSeek&lt;Int, Dbl&gt;&amp;) )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (!conf.gen_set) {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;No generator set for in seek tag. Aborting.\n&quot;</span>;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!(conf.test_set)) {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;No test set for in seek tag. Aborting.\n&quot;</span>;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!conf.proj_set) {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;No projections set for in seek tag. Aborting.\n&quot;</span>;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Initializing values</span></div>
<div class="line">    <span class="comment">// Dynamically allocated objects</span></div>
<div class="line">    timer.init();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> old = 0;</div>
<div class="line">    <span class="comment">// Launching the tests</span></div>
<div class="line">    <span class="keywordflow">if</span> (conf.progress) {</div>
<div class="line">      old = print_progress(-1);</div>
<div class="line">    }</div>
<div class="line">    MeritList&lt;Lat&gt; bestLattice(conf.max_gen, conf.best);</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (lat != NULL) <span class="keyword">delete</span> lat;</div>
<div class="line">      lat = nextGenerator(conf);</div>
<div class="line">      <span class="keywordflow">if</span> (lat == NULL) <span class="keywordflow">continue</span>;</div>
<div class="line">      bestLattice.add(test_seek(*lat, conf));</div>
<div class="line">      conf.num_gen++;</div>
<div class="line">      conf.currentMerit = bestLattice.getMerit();</div>
<div class="line">      <span class="keywordflow">if</span> (conf.progress) old = print_progress(old);</div>
<div class="line">    } <span class="keywordflow">while</span> (!timer.timeOver(conf.timeLimit) &amp;&amp; lat);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\r                                                                                                          \r&quot;</span>;</div>
<div class="line">    printResults(bestLattice);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">}; <span class="comment">// end struct SeekMain</span></div>
</div><!-- fragment --><p> This function takes a pointer to a function as an argument. This function passed as an argument is used at each step to search and return the next generator to test. Following this logic, there is only need to implement another function to pass as <code>nextGenerator</code> and to make it such that the program can pass it to <code>Seek()</code>.</p>
<h3><a class="anchor" id="next_gen"></a>
nextGenerator Functions</h3>
<h3><a class="anchor" id="program_exec_mod"></a>
Accessing the New Function</h3>
<p>This means that searching generators with a new method can be done by implementing this method in a new function and modifying the executable for this function to be passed to the search method. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jul 18 2025 21:40:38 for LatMRG API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
