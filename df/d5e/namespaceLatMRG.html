<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatMRG Online Documentation: LatMRG Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatMRG Online Documentation<span id="projectnumber">&#160;unknown</span>
   </div>
   <div id="projectbrief">Tools to analyze the lattice structure of linear generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('df/d5e/namespaceLatMRG.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">LatMRG Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This has to be redone in a way similar to <span class="tt">Rank1Lattice</span>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AWCSWBLattice" id="r_AWCSWBLattice"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d07/classLatMRG_1_1AWCSWBLattice.html">AWCSWBLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the lattice associated with either an AWC or a SWB random number generator.  <a href="../../d1/d07/classLatMRG_1_1AWCSWBLattice.html#details">More...</a><br /></td></tr>
<tr class="memitem:ComboLattice" id="r_ComboLattice"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d2b/classLatMRG_1_1ComboLattice.html">ComboLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a combined MRG.  <a href="../../de/d2b/classLatMRG_1_1ComboLattice.html#details">More...</a><br /></td></tr>
<tr class="memitem:FlexModInt" id="r_FlexModInt"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <span class="tt"><a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html" title="The FlexModInt class permits one to use the NTL functions that work on integers, vectors,...">FlexModInt</a></span> class permits one to use the NTL functions that work on integers, vectors, and polynomials over <span class="tt">Z_p</span> (with arithmetic modulo p) using the flexible type <span class="tt">Int</span> for the modulus and coefficients.  <a href="../../da/db0/classLatMRG_1_1FlexModInt.html#details">More...</a><br /></td></tr>
<tr class="memitem:FlexModInt_3C_20NTL_3A_3AZZ_20_3E" id="r_FlexModInt_3C_20NTL_3A_3AZZ_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/ddd/classLatMRG_1_1FlexModInt_3_01NTL_1_1ZZ_01_4.html">FlexModInt&lt; NTL::ZZ &gt;</a></td></tr>
<tr class="memitem:FlexModInt_3C_20std_3A_3Aint64_5Ft_20_3E" id="r_FlexModInt_3C_20std_3A_3Aint64_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dda/classLatMRG_1_1FlexModInt_3_01std_1_1int64__t_01_4.html">FlexModInt&lt; std::int64_t &gt;</a></td></tr>
<tr class="memitem:IntFactor" id="r_IntFactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d62/classLatMRG_1_1IntFactor.html">IntFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of this class represents a factor in the decomposition of a positive integer.  <a href="../../d1/d62/classLatMRG_1_1IntFactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:IntFactorization" id="r_IntFactorization"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the factorization of an arbitrary positive integer, usually into prime factors, but not always.  <a href="../../dc/d6c/classLatMRG_1_1IntFactorization.html#details">More...</a><br /></td></tr>
<tr class="memitem:LCGComponent" id="r_LCGComponent"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd6/classLatMRG_1_1LCGComponent.html">LCGComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers tools to test the period of an LCG recurrence modulo \(m\), of the form.  <a href="../../d0/dd6/classLatMRG_1_1LCGComponent.html#details">More...</a><br /></td></tr>
<tr class="memitem:LCGLattice" id="r_LCGLattice"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8f/classLatMRG_1_1LCGLattice.html">LCGLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class handles lattices that are produced by linear congruential generators (LCGs).  <a href="../../d0/d8f/classLatMRG_1_1LCGLattice.html#details">More...</a><br /></td></tr>
<tr class="memitem:MixmaxMMRG" id="r_MixmaxMMRG"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d52/classLatMRG_1_1MixmaxMMRG.html">MixmaxMMRG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to manipulate easily MMRG of Mixmax types as described by Savvidy [CITE PAPER].  <a href="../../d2/d52/classLatMRG_1_1MixmaxMMRG.html#details">More...</a><br /></td></tr>
<tr class="memitem:MMRGLattice" id="r_MMRGLattice"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d2c/classLatMRG_1_1MMRGLattice.html">MMRGLattice</a></td></tr>
<tr class="memitem:Modulus" id="r_Modulus"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d81/classLatMRG_1_1Modulus.html">Modulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers a few tools to work with a modulus <span class="tt">m</span>.  <a href="../../df/d81/classLatMRG_1_1Modulus.html#details">More...</a><br /></td></tr>
<tr class="memitem:MRGComponent" id="r_MRGComponent"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d84/classLatMRG_1_1MRGComponent.html">MRGComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers tools to verify if an MRG recurrence or order \(k\) modulo \(m\), of the form.  <a href="../../d9/d84/classLatMRG_1_1MRGComponent.html#details">More...</a><br /></td></tr>
<tr class="memitem:MRGLattice" id="r_MRGLattice"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html">MRGLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subclass of <span class="tt">IntLatticeExt</span> defines an MRG lattice and is similar to Rank1Lattice, but constructs lattices associated with multiple recursive generators (MRGs) with modulus m, order k, and vector of multipliers a = (a_1, .  <a href="../../d6/d04/classLatMRG_1_1MRGLattice.html#details">More...</a><br /></td></tr>
<tr class="memitem:MRGLatticeLac" id="r_MRGLatticeLac"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc4/classLatMRG_1_1MRGLatticeLac.html">MRGLatticeLac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subclass of <span class="tt"><a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html" title="This subclass of IntLatticeExt defines an MRG lattice and is similar to Rank1Lattice,...">MRGLattice</a></span> constructs and handles lattice bases built from MRGs as in <span class="tt"><a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html" title="This subclass of IntLatticeExt defines an MRG lattice and is similar to Rank1Lattice,...">MRGLattice</a></span>, but with arbitrary lacunary indices that can be spaced very far apart.  <a href="../../da/dc4/classLatMRG_1_1MRGLatticeLac.html#details">More...</a><br /></td></tr>
<tr class="memitem:MWCComponent" id="r_MWCComponent"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dbe/classLatMRG_1_1MWCComponent.html">MWCComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the lattice associated to a Multiply-with-carry (MWC) random number generator.  <a href="../../de/dbe/classLatMRG_1_1MWCComponent.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afac2b812b1032e05d3021526a3a0b63c" id="r_afac2b812b1032e05d3021526a3a0b63c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afac2b812b1032e05d3021526a3a0b63c">PrimeType</a> { <a class="el" href="#afac2b812b1032e05d3021526a3a0b63ca2404025fba4b3cfa77331ab4792d0c5f">PRIME</a>
, <a class="el" href="#afac2b812b1032e05d3021526a3a0b63ca13a18950a0b37607dc414611b2ad6580">PROB_PRIME</a>
, <a class="el" href="#afac2b812b1032e05d3021526a3a0b63ca5f1155e09b4d09a2af57e8646301a892">COMPOSITE</a>
, <a class="el" href="#afac2b812b1032e05d3021526a3a0b63cadec4919030ac8bfbf3483ebe3125a60e">UNKNOWN</a>
 }</td></tr>
<tr class="memdesc:afac2b812b1032e05d3021526a3a0b63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integer is prime, probably prime, composite, or its status is unknown (or we do not care).  <a href="#afac2b812b1032e05d3021526a3a0b63c">More...</a><br /></td></tr>
<tr class="memitem:ab4948e899f8c3a6fb82cff009283061e" id="r_ab4948e899f8c3a6fb82cff009283061e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4948e899f8c3a6fb82cff009283061e">GenType</a> { <br />
&#160;&#160;<a class="el" href="#ab4948e899f8c3a6fb82cff009283061ea94058d727954dae2f0a4d63a908b3d83">LCG</a>
, <a class="el" href="#ab4948e899f8c3a6fb82cff009283061ea3dc38938093e9c5665f60c383e03d472">MRG</a>
, <a class="el" href="#ab4948e899f8c3a6fb82cff009283061ea704886e207cd0fadc91d5bcc0139a78d">MMRG</a>
, <a class="el" href="#ab4948e899f8c3a6fb82cff009283061ea9a98771a3304da67b9ed878d6e0aa1c9">MWC</a>
, <br />
&#160;&#160;<a class="el" href="#ab4948e899f8c3a6fb82cff009283061ead6c0d4e17150b4a449106a8a9c55c9b7">COMBO</a>
<br />
 }</td></tr>
<tr class="memdesc:ab4948e899f8c3a6fb82cff009283061e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of generators handled by <a class="el" href="df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a>.  <a href="#ab4948e899f8c3a6fb82cff009283061e">More...</a><br /></td></tr>
<tr class="memitem:a86edf8445f847038592d741fd49b2b09" id="r_a86edf8445f847038592d741fd49b2b09"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86edf8445f847038592d741fd49b2b09">LatticeType</a> { <a class="el" href="#a86edf8445f847038592d741fd49b2b09aadd01ce47ad19c016e7dcaf75dc70810">FULL</a>
, <a class="el" href="#a86edf8445f847038592d741fd49b2b09a180301d85d165e3f563c11ed9f955b04">RECURRENT</a>
, <a class="el" href="#a86edf8445f847038592d741fd49b2b09a7193d9616b86142a852b828d15a03f84">ORBIT</a>
, <a class="el" href="#a86edf8445f847038592d741fd49b2b09a7677349e86aa9f7110f03320a428cfc6">PRIMEPOWER</a>
 }</td></tr>
<tr class="memdesc:a86edf8445f847038592d741fd49b2b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether to analyze the lattice generated by all possible states, or a sub-lattice generated by the set of recurrent states or by a sub-cycle of the generator.  <a href="#a86edf8445f847038592d741fd49b2b09">More...</a><br /></td></tr>
<tr class="memitem:abab34306ba3f65f06d4919d4ae54d3f1" id="r_abab34306ba3f65f06d4919d4ae54d3f1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1">DecompType</a> { <br />
&#160;&#160;<a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1ae594a4a78d0d11ae51b51a87b3e9b4a3">DECOMP</a>
, <a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1a20fc861188044c65f9b1bd42d29e7806">DECOMP_WRITE</a>
, <a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1a9da3c652f9e8a5b551e0700723f4ac44">DECOMP_READ</a>
, <a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1ae2fa14b3e79878731d2d94369e0aa2a3">DECOMP_PRIME</a>
, <br />
&#160;&#160;<a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1af7ce8bb8e6065228c3e34270131739f3">NO_DECOMP</a>
<br />
 }</td></tr>
<tr class="memdesc:abab34306ba3f65f06d4919d4ae54d3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an integer \(x\), this type indicates what to do about the decomposition of \(x\) in its prime factors, in the class <span class="tt">IntFactorization</span>.  <a href="#abab34306ba3f65f06d4919d4ae54d3f1">More...</a><br /></td></tr>
<tr class="memitem:ad049f9925bbec6f1e1b8097723c01d95" id="r_ad049f9925bbec6f1e1b8097723c01d95"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95">ImplemCond</a> { <br />
&#160;&#160;<a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95ad9ab360d18c9302b90dd714d35a0c132">NO_COND</a>
, <a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95adc39f6458d387d2cfc655b1f02d4f3d7">APP_FACT</a>
, <a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95a3e31685740aafc4bef9f3508db0bec77">POWER_TWO</a>
, <a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95aa6f98d6ee60b601dd3f366499899cd67">EQUAL_COEF</a>
, <br />
&#160;&#160;<a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95aff9dd7625c374d20ef6ba6a9bf5f0e12">ZERO_COEF</a>
<br />
 }</td></tr>
<tr class="memdesc:ad049f9925bbec6f1e1b8097723c01d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of conditions are imposed on the coefficients \(a_i\) of a recurrence.  <a href="#ad049f9925bbec6f1e1b8097723c01d95">More...</a><br /></td></tr>
<tr class="memitem:a1fd35b5cabbc11ccb440e722240ca3e8" id="r_a1fd35b5cabbc11ccb440e722240ca3e8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fd35b5cabbc11ccb440e722240ca3e8">SearchMethod</a> { <a class="el" href="#a1fd35b5cabbc11ccb440e722240ca3e8af348ef97764bf697a7be024947e10330">EXHAUST</a>
, <a class="el" href="#a1fd35b5cabbc11ccb440e722240ca3e8a57df570a60b5ea66ef4a74640b026c8b">RANDOM</a>
 }</td></tr>
<tr class="memdesc:a1fd35b5cabbc11ccb440e722240ca3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the search method used to find good multipliers \(a_i\).  <a href="#a1fd35b5cabbc11ccb440e722240ca3e8">More...</a><br /></td></tr>
<tr class="memitem:ab24055f29985bdc83f514e803c4f7bda" id="r_ab24055f29985bdc83f514e803c4f7bda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab24055f29985bdc83f514e803c4f7bda">LacunaryType</a> { <a class="el" href="#ab24055f29985bdc83f514e803c4f7bdaace6d51c2ece6bb392ade633f25bcf9c2">NONE</a>
, <a class="el" href="#ab24055f29985bdc83f514e803c4f7bdaab76e637b32947ec260a58def7b11b6b7">SUBVECTOR</a>
, <a class="el" href="#ab24055f29985bdc83f514e803c4f7bdaa44a10b67651488cf044f3bdabad7fe15">ARBITRARYINDICES</a>
 }</td></tr>
<tr class="memdesc:ab24055f29985bdc83f514e803c4f7bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the type of lacunary projection used in <span class="tt">MMRGLattice</span>:  <a href="#ab24055f29985bdc83f514e803c4f7bda">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a671c2035934701d0aad78ff85a41a11f" id="r_a671c2035934701d0aad78ff85a41a11f"><td class="memTemplParams" colspan="2">template&lt;typename Int, typename Real&gt; </td></tr>
<tr class="memitem:a671c2035934701d0aad78ff85a41a11f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html">MRGLattice</a>&lt; Int, Real &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a671c2035934701d0aad78ff85a41a11f">getLatCombo</a> (std::vector&lt; MRGPeriod&lt; Int &gt; * &gt; &amp;comp, int maxDim)</td></tr>
<tr class="memdesc:a671c2035934701d0aad78ff85a41a11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes and returns a <span class="tt"><a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html" title="This subclass of IntLatticeExt defines an MRG lattice and is similar to Rank1Lattice,...">MRGLattice</a></span> that is the lattice of the combination of generators described in the <span class="tt">MRGPeriod</span>s in the vector <span class="tt">comp</span>.  <br /></td></tr>
<tr class="memitem:a46e2b79fe37f6b1e64552fe795a32a14" id="r_a46e2b79fe37f6b1e64552fe795a32a14"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html">MRGLattice</a>&lt; std::int64_t, double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46e2b79fe37f6b1e64552fe795a32a14">getLatCombo</a> (std::vector&lt; MRGPeriod&lt; std::int64_t &gt; * &gt; &amp;comp, int maxDim)</td></tr>
<tr class="memitem:a30a18ac8dfd5ed29fedda9ca9d25eb33" id="r_a30a18ac8dfd5ed29fedda9ca9d25eb33"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html">MRGLattice</a>&lt; NTL::ZZ, double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30a18ac8dfd5ed29fedda9ca9d25eb33">getLatCombo</a> (std::vector&lt; MRGPeriod&lt; NTL::ZZ &gt; * &gt; &amp;comp, int maxDim)</td></tr>
<tr class="memitem:aa722e6aa0789707125e1505a97a18abb" id="r_aa722e6aa0789707125e1505a97a18abb"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa722e6aa0789707125e1505a97a18abb">toStringPrimeType</a> (<a class="el" href="#afac2b812b1032e05d3021526a3a0b63c">PrimeType</a> prime)</td></tr>
<tr class="memdesc:aa722e6aa0789707125e1505a97a18abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following are functions for printing the <span class="tt">enum</span> constants in this module.  <br /></td></tr>
<tr class="memitem:a317cea9c7556eb472e6589f896d4e537" id="r_a317cea9c7556eb472e6589f896d4e537"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a317cea9c7556eb472e6589f896d4e537">toStringGenType</a> (<a class="el" href="#ab4948e899f8c3a6fb82cff009283061e">GenType</a> gen)</td></tr>
<tr class="memitem:a0f1c234d3d916c8db4595998a9742e02" id="r_a0f1c234d3d916c8db4595998a9742e02"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f1c234d3d916c8db4595998a9742e02">toStringLatticeType</a> (<a class="el" href="#a86edf8445f847038592d741fd49b2b09">LatticeType</a> lat)</td></tr>
<tr class="memitem:adabf852a26ad5fae6802ab50db439cec" id="r_adabf852a26ad5fae6802ab50db439cec"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adabf852a26ad5fae6802ab50db439cec">toStringDecompType</a> (<a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1">DecompType</a> decomp)</td></tr>
<tr class="memitem:a5f0a03ca1af239f9818b4f6ac3820b26" id="r_a5f0a03ca1af239f9818b4f6ac3820b26"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f0a03ca1af239f9818b4f6ac3820b26">toStringImplemCond</a> (<a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95">ImplemCond</a> implem)</td></tr>
<tr class="memitem:ae3aaab7957188b6822a58a1b668b9f05" id="r_ae3aaab7957188b6822a58a1b668b9f05"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3aaab7957188b6822a58a1b668b9f05">toStringSearchMethod</a> (<a class="el" href="#a1fd35b5cabbc11ccb440e722240ca3e8">SearchMethod</a> searchm)</td></tr>
<tr class="memitem:a415796c7d63f465cede62fbdf9ba1d70" id="r_a415796c7d63f465cede62fbdf9ba1d70"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415796c7d63f465cede62fbdf9ba1d70">toStringLacunaryType</a> (<a class="el" href="#ab24055f29985bdc83f514e803c4f7bda">LacunaryType</a> lacunary)</td></tr>
<tr class="memitem:aca6bf48506108b28ac831839120a7ab5" id="r_aca6bf48506108b28ac831839120a7ab5"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:aca6bf48506108b28ac831839120a7ab5 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca6bf48506108b28ac831839120a7ab5">setModulusIntP</a> (const Int &amp;m)</td></tr>
<tr class="memdesc:aca6bf48506108b28ac831839120a7ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets to <span class="tt">m</span> the modulus used by NTL for its <span class="tt">IntP</span> calculations.  <br /></td></tr>
<tr class="memitem:a7202935548ae566ad85f3710bfefa548" id="r_a7202935548ae566ad85f3710bfefa548"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a7202935548ae566ad85f3710bfefa548 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7202935548ae566ad85f3710bfefa548">findPrime</a> (int64_t e, int64_t s, bool facto, std::ostream &amp;fout, const int64_t RMtrials=200)</td></tr>
<tr class="memdesc:a7202935548ae566ad85f3710bfefa548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and prints the \(s\) largest prime integers \(m &lt; 2^e\).  <br /></td></tr>
<tr class="memitem:ae5afab0c8e00d159b6f5cbba1a5f328f" id="r_ae5afab0c8e00d159b6f5cbba1a5f328f"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:ae5afab0c8e00d159b6f5cbba1a5f328f template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5afab0c8e00d159b6f5cbba1a5f328f">findPrime</a> (int64_t k, int64_t e, int64_t s, bool safe, bool facto, std::ostream &amp;fout, const int64_t RMtrials=200)</td></tr>
<tr class="memdesc:ae5afab0c8e00d159b6f5cbba1a5f328f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the \(s\) largest prime integers \(m&lt;2^e\) for which \(r = (m^k-1)/(m-1)\) is also prime.  <br /></td></tr>
<tr class="memitem:a612045696ae0d10586a43c0aa052d7f9" id="r_a612045696ae0d10586a43c0aa052d7f9"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a612045696ae0d10586a43c0aa052d7f9 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a612045696ae0d10586a43c0aa052d7f9">findPrime</a> (int64_t k, int64_t e, int64_t c1, int64_t c2, bool safe, bool facto, std::ostream &amp;fout, const int64_t RMtrials=200)</td></tr>
<tr class="memdesc:a612045696ae0d10586a43c0aa052d7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all integers \(m\), in \(2^e + c_1 \le m \le 2^e + c_2\), such that \(m\) and \(r = (m^k-1)/(m-1)\) are prime.  <br /></td></tr>
<tr class="memitem:a7942d3c5fd5b08b6313554c782c02235" id="r_a7942d3c5fd5b08b6313554c782c02235"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a7942d3c5fd5b08b6313554c782c02235 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7942d3c5fd5b08b6313554c782c02235">findPrime</a> (int64_t k, int64_t e, int64_t s, const Int &amp;S1, const Int &amp;S2, bool safe, bool facto, std::ostream &amp;fout, const int64_t RMtrials=200)</td></tr>
<tr class="memdesc:a7942d3c5fd5b08b6313554c782c02235"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the general purpose function, called by the other ones.  <br /></td></tr>
<tr class="memitem:afa05d41c55fb8a6d08fccc838af7c1f1" id="r_afa05d41c55fb8a6d08fccc838af7c1f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa05d41c55fb8a6d08fccc838af7c1f1">writeHeader</a> (int64_t k, int64_t e, int64_t c1, int64_t c2, bool safe, bool facto, std::ostream &amp;fout, const int64_t RMtrials=200)</td></tr>
<tr class="memdesc:afa05d41c55fb8a6d08fccc838af7c1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the search parameters to the stream <span class="tt">fout</span>.  <br /></td></tr>
<tr class="memitem:ab566f101d19952cf7e4d88dd97e5167c" id="r_ab566f101d19952cf7e4d88dd97e5167c"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:ab566f101d19952cf7e4d88dd97e5167c template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab566f101d19952cf7e4d88dd97e5167c">nextM</a> (Int &amp;m)</td></tr>
<tr class="memitem:a8d42e8aeb4a56d55b039cf0f29b3231e" id="r_a8d42e8aeb4a56d55b039cf0f29b3231e"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a8d42e8aeb4a56d55b039cf0f29b3231e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d42e8aeb4a56d55b039cf0f29b3231e">findPrime</a> (int64_t k, int64_t e, int64_t s, const Int &amp;S1, const Int &amp;S2, bool safe, bool facto, std::ostream &amp;fout, const int64_t RMtrials)</td></tr>
<tr class="memdesc:a8d42e8aeb4a56d55b039cf0f29b3231e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the general purpose function, called by the other ones.  <br /></td></tr>
<tr class="memitem:a84b942c989a2c5bacdd76daf9961a948" id="r_a84b942c989a2c5bacdd76daf9961a948"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a84b942c989a2c5bacdd76daf9961a948 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84b942c989a2c5bacdd76daf9961a948">findPrime</a> (int64_t e, int64_t s, bool facto, std::ostream &amp;fout, const int64_t RMtrials)</td></tr>
<tr class="memdesc:a84b942c989a2c5bacdd76daf9961a948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and prints the \(s\) largest prime integers \(m &lt; 2^e\).  <br /></td></tr>
<tr class="memitem:a586ec61c87ad0672a9fd2ad02df6e475" id="r_a586ec61c87ad0672a9fd2ad02df6e475"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a586ec61c87ad0672a9fd2ad02df6e475 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a586ec61c87ad0672a9fd2ad02df6e475">findPrime</a> (int64_t k, int64_t e, int64_t s, bool safe, bool facto, std::ostream &amp;fout, const int64_t RMtrials)</td></tr>
<tr class="memdesc:a586ec61c87ad0672a9fd2ad02df6e475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the \(s\) largest prime integers \(m&lt;2^e\) for which \(r = (m^k-1)/(m-1)\) is also prime.  <br /></td></tr>
<tr class="memitem:a78bfd721e993605107bc9749a2834408" id="r_a78bfd721e993605107bc9749a2834408"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a78bfd721e993605107bc9749a2834408 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78bfd721e993605107bc9749a2834408">findPrime</a> (int64_t k, int64_t e, int64_t c1, int64_t c2, bool safe, bool facto, std::ostream &amp;fout, const int64_t RMtrials)</td></tr>
<tr class="memdesc:a78bfd721e993605107bc9749a2834408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all integers \(m\), in \(2^e + c_1 \le m \le 2^e + c_2\), such that \(m\) and \(r = (m^k-1)/(m-1)\) are prime.  <br /></td></tr>
<tr class="memitem:a0a60e636843f69cfc80a35c8ac034d5f" id="r_a0a60e636843f69cfc80a35c8ac034d5f"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a0a60e636843f69cfc80a35c8ac034d5f template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a60e636843f69cfc80a35c8ac034d5f">isPrimitiveElement</a> (const Int &amp;a, const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;fac, const Int &amp;p, long e=1)</td></tr>
<tr class="memdesc:a0a60e636843f69cfc80a35c8ac034d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides static functions to test for the primitivity of an integer or a polynomial in a finite field.  <br /></td></tr>
<tr class="memitem:a5c87d7b433d4c7463eff0676b949d5fb" id="r_a5c87d7b433d4c7463eff0676b949d5fb"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a5c87d7b433d4c7463eff0676b949d5fb template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c87d7b433d4c7463eff0676b949d5fb">isPrimitive</a> (const NTL::Vec&lt; Int &gt; &amp;aa, const Int &amp;m, const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;fm, const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;fr)</td></tr>
<tr class="memdesc:a5c87d7b433d4c7463eff0676b949d5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> iff the polynomial \(f\) is a primitive polynomial modulo \(m\).  <br /></td></tr>
<tr class="memitem:a9528f80c9264d3a72fec99dc016bac3e" id="r_a9528f80c9264d3a72fec99dc016bac3e"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a9528f80c9264d3a72fec99dc016bac3e template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9528f80c9264d3a72fec99dc016bac3e">isPrimitive23</a> (const NTL::Vec&lt; Int &gt; &amp;aa, const Int &amp;m, const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;fr)</td></tr>
<tr class="memdesc:a9528f80c9264d3a72fec99dc016bac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <span class="tt">isPrimitive</span> above, except that this function only checks for Conditions 2 and 3.  <br /></td></tr>
<tr class="memitem:ace6e9031b7cd981bc36c0ee69ab27aea" id="r_ace6e9031b7cd981bc36c0ee69ab27aea"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:ace6e9031b7cd981bc36c0ee69ab27aea template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace6e9031b7cd981bc36c0ee69ab27aea">setCharacPoly</a> (typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;f, const NTL::Vec&lt; Int &gt; &amp;aa)</td></tr>
<tr class="memdesc:ace6e9031b7cd981bc36c0ee69ab27aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the coefficients of the polynomial <span class="tt">f</span> so it corresponds to the characteristic polynomial \(P(z) = z^k - a_1 z^{k-1} - \cdots- a_{k-1} z - a_k\) with coefficients \(c_{k-j} = a_j = \)<span class="tt">aa[j]</span>.  <br /></td></tr>
<tr class="memitem:af02c4541e113a9fc821da559d63ac0b0" id="r_af02c4541e113a9fc821da559d63ac0b0"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:af02c4541e113a9fc821da559d63ac0b0 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af02c4541e113a9fc821da559d63ac0b0">setCharacPoly</a> (typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;f, typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::IntVecP &amp;aaP)</td></tr>
<tr class="memdesc:af02c4541e113a9fc821da559d63ac0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this version, the vector of coefficients is passed directly as an <span class="tt">IntVecP</span>, so there is no need to convert it internally (this is more efficient).  <br /></td></tr>
<tr class="memitem:a449fc348bca5c3d64f14a8f60c862d81" id="r_a449fc348bca5c3d64f14a8f60c862d81"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a449fc348bca5c3d64f14a8f60c862d81 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a449fc348bca5c3d64f14a8f60c862d81">vecMRGToPoly</a> (typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;f, typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::IntVecP aaP, const NTL::Vec&lt; Int &gt; &amp;xx)</td></tr>
<tr class="memdesc:a449fc348bca5c3d64f14a8f60c862d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the vector state <span class="tt">xx</span> of an MRG to its polynomial representation in <span class="tt">f</span>.  <br /></td></tr>
<tr class="memitem:a80797562d84af6a39970188ffb870675" id="r_a80797562d84af6a39970188ffb870675"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a80797562d84af6a39970188ffb870675 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80797562d84af6a39970188ffb870675">polyToVecMRG</a> (const NTL::Vec&lt; Int &gt; &amp;xx, typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::IntVecP aaP, typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;f)</td></tr>
<tr class="memdesc:a80797562d84af6a39970188ffb870675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the polynomial representation in <span class="tt">f</span> to the vector state <span class="tt">xx</span> of an MRG, with <span class="tt">xx[j]</span> \(x_{n-k+1+j]\).  <br /></td></tr>
<tr class="memitem:a5809a59baeaac412e2819b5388c4cd51" id="r_a5809a59baeaac412e2819b5388c4cd51"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a5809a59baeaac412e2819b5388c4cd51 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5809a59baeaac412e2819b5388c4cd51">isPrimitiveElement</a> (const Int &amp;a, const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;fac, const Int &amp;p, long e)</td></tr>
<tr class="memdesc:a5809a59baeaac412e2819b5388c4cd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in <span class="tt">fj</span> the polynomial \(x^j \mod f(x) (\bmod m)\) where \(f(x)\) is the polynomial with coefficients in 'C', modulo 'm'.  <br /></td></tr>
<tr class="memitem:a612afc59cdc99759cfcc088f5cc12be5" id="r_a612afc59cdc99759cfcc088f5cc12be5"><td class="memTemplParams" colspan="2">template&lt;typename Int&gt; </td></tr>
<tr class="memitem:a612afc59cdc99759cfcc088f5cc12be5 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a612afc59cdc99759cfcc088f5cc12be5">setCharacPoly</a> (typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;f, typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::IntVecP aaP)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad56a743819a7b2ab0ae95fae3c97d9a3" id="r_ad56a743819a7b2ab0ae95fae3c97d9a3"><td class="memItemLeft" align="right" valign="top">static constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad56a743819a7b2ab0ae95fae3c97d9a3">NB_PRIMES</a> = 6543</td></tr>
<tr class="memitem:a32bf71856a2c14d79708d3ccfff94985" id="r_a32bf71856a2c14d79708d3ccfff94985"><td class="memItemLeft" align="right" valign="top">const std::array&lt; uint64_t, <a class="el" href="#ad56a743819a7b2ab0ae95fae3c97d9a3">NB_PRIMES</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32bf71856a2c14d79708d3ccfff94985">PRIMES_ARRAY</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This has to be redone in a way similar to <span class="tt">Rank1Lattice</span>. </p>
<p>Anything to change or to add ??? ********************** </p>
</div><a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="afac2b812b1032e05d3021526a3a0b63c" name="afac2b812b1032e05d3021526a3a0b63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac2b812b1032e05d3021526a3a0b63c">&#9670;&#160;</a></span>PrimeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#afac2b812b1032e05d3021526a3a0b63c">LatMRG::PrimeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether an integer is prime, probably prime, composite, or its status is unknown (or we do not care). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afac2b812b1032e05d3021526a3a0b63ca2404025fba4b3cfa77331ab4792d0c5f" name="afac2b812b1032e05d3021526a3a0b63ca2404025fba4b3cfa77331ab4792d0c5f"></a>PRIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afac2b812b1032e05d3021526a3a0b63ca13a18950a0b37607dc414611b2ad6580" name="afac2b812b1032e05d3021526a3a0b63ca13a18950a0b37607dc414611b2ad6580"></a>PROB_PRIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afac2b812b1032e05d3021526a3a0b63ca5f1155e09b4d09a2af57e8646301a892" name="afac2b812b1032e05d3021526a3a0b63ca5f1155e09b4d09a2af57e8646301a892"></a>COMPOSITE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afac2b812b1032e05d3021526a3a0b63cadec4919030ac8bfbf3483ebe3125a60e" name="afac2b812b1032e05d3021526a3a0b63cadec4919030ac8bfbf3483ebe3125a60e"></a>UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab4948e899f8c3a6fb82cff009283061e" name="ab4948e899f8c3a6fb82cff009283061e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4948e899f8c3a6fb82cff009283061e">&#9670;&#160;</a></span>GenType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab4948e899f8c3a6fb82cff009283061e">LatMRG::GenType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of generators handled by <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a>. </p>
<p><span class="tt">LCG</span>: linear congruential generator with a carry.<br  />
 <span class="tt">MRG</span>: multiple-recursive generator.<br  />
 <span class="tt">MMRG</span>: matrix multiple-recursive generator.<br  />
 <span class="tt">MWC</span>: multiply-with-carry generator. Usually transformed into an LCG. <br  />
 <span class="tt">COMBO</span>: a combined generator, with either MRG or MWC components. <br  />
 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab4948e899f8c3a6fb82cff009283061ea94058d727954dae2f0a4d63a908b3d83" name="ab4948e899f8c3a6fb82cff009283061ea94058d727954dae2f0a4d63a908b3d83"></a>LCG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab4948e899f8c3a6fb82cff009283061ea3dc38938093e9c5665f60c383e03d472" name="ab4948e899f8c3a6fb82cff009283061ea3dc38938093e9c5665f60c383e03d472"></a>MRG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab4948e899f8c3a6fb82cff009283061ea704886e207cd0fadc91d5bcc0139a78d" name="ab4948e899f8c3a6fb82cff009283061ea704886e207cd0fadc91d5bcc0139a78d"></a>MMRG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab4948e899f8c3a6fb82cff009283061ea9a98771a3304da67b9ed878d6e0aa1c9" name="ab4948e899f8c3a6fb82cff009283061ea9a98771a3304da67b9ed878d6e0aa1c9"></a>MWC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab4948e899f8c3a6fb82cff009283061ead6c0d4e17150b4a449106a8a9c55c9b7" name="ab4948e899f8c3a6fb82cff009283061ead6c0d4e17150b4a449106a8a9c55c9b7"></a>COMBO&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a86edf8445f847038592d741fd49b2b09" name="a86edf8445f847038592d741fd49b2b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86edf8445f847038592d741fd49b2b09">&#9670;&#160;</a></span>LatticeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a86edf8445f847038592d741fd49b2b09">LatMRG::LatticeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether to analyze the lattice generated by all possible states, or a sub-lattice generated by the set of recurrent states or by a sub-cycle of the generator. </p>
<p><span class="tt">FULL</span>: The complete lattice, generated by all possible initial states, will be analyzed.<br  />
 <span class="tt">RECURRENT</span>: If the (combined) generator has transient states, then the lattice analyzed will be the sub-lattice generated by the set of recurrent states.<br  />
 <span class="tt">ORBIT</span>: The grid generated by the (forward) orbit of a state of the (combined) generator is analyzed. This state is specified as follows: on the following \(J\) lines, the initial state for each component must be given. This is an integer vector with a number of components equal to the order of the component.<br  />
 <span class="tt">PRIMEPOWER</span>: In the case where some component is an MLCG whose modulus is a power of a prime \(p\), then the states visited over a single orbit (sub-cycle) of that component generate a sub-lattice (when  \(a
\equiv1 \bmod p\)) or belong to the union of \(p-1\) sub-lattices (otherwise). If <span class="tt"><a class="el" href="#a86edf8445f847038592d741fd49b2b09" title="Indicates whether to analyze the lattice generated by all possible states, or a sub-lattice generated...">LatticeType</a></span> takes this value, and a component is a MLCG ( \(k=1\)), and if the modulus of that MLCG is given in the data file in the form (b): \((x y z)\) with \(z=0\) and \(x\) prime, then what is analyzed is one of those sub-lattices. This is done by dividing the modulus by the appropriate power of \(p\), as described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rlec94e">[4]</a>&thinsp;. For example, if \(p=2\) and \(a \mod8 = 5\), then the modulus is divided by 4 as in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rfis90a">[2]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_rknu81a">[3]</a>&thinsp;. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a86edf8445f847038592d741fd49b2b09aadd01ce47ad19c016e7dcaf75dc70810" name="a86edf8445f847038592d741fd49b2b09aadd01ce47ad19c016e7dcaf75dc70810"></a>FULL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86edf8445f847038592d741fd49b2b09a180301d85d165e3f563c11ed9f955b04" name="a86edf8445f847038592d741fd49b2b09a180301d85d165e3f563c11ed9f955b04"></a>RECURRENT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86edf8445f847038592d741fd49b2b09a7193d9616b86142a852b828d15a03f84" name="a86edf8445f847038592d741fd49b2b09a7193d9616b86142a852b828d15a03f84"></a>ORBIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86edf8445f847038592d741fd49b2b09a7677349e86aa9f7110f03320a428cfc6" name="a86edf8445f847038592d741fd49b2b09a7677349e86aa9f7110f03320a428cfc6"></a>PRIMEPOWER&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="abab34306ba3f65f06d4919d4ae54d3f1" name="abab34306ba3f65f06d4919d4ae54d3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab34306ba3f65f06d4919d4ae54d3f1">&#9670;&#160;</a></span>DecompType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1">LatMRG::DecompType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an integer \(x\), this type indicates what to do about the decomposition of \(x\) in its prime factors, in the class <span class="tt"><a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html" title="Represents the factorization of an arbitrary positive integer, usually into prime factors,...">IntFactorization</a></span>. </p>
<p><span class="tt">DECOMP</span>: means that the program will factorize \(x\).<br  />
 <span class="tt">DECOMP_WRITE</span>: means that the program will factorize \(x\) and writes the factors in a file, in the same format as for <span class="tt">read</span> below. <br  />
 <span class="tt">DECOMP_READ</span>: means that \(x\) is already factorized, and the factors will be read from a file, using function <span class="tt">read</span> below.<br  />
 <span class="tt">DECOMP_PRIME</span>: means that \(x\) is assumed to be prime. No factorization will be done. <span class="tt">NO_DECOMP</span>: The program will not make a decomposition in prime factors. Used when not checking the period. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abab34306ba3f65f06d4919d4ae54d3f1ae594a4a78d0d11ae51b51a87b3e9b4a3" name="abab34306ba3f65f06d4919d4ae54d3f1ae594a4a78d0d11ae51b51a87b3e9b4a3"></a>DECOMP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abab34306ba3f65f06d4919d4ae54d3f1a20fc861188044c65f9b1bd42d29e7806" name="abab34306ba3f65f06d4919d4ae54d3f1a20fc861188044c65f9b1bd42d29e7806"></a>DECOMP_WRITE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abab34306ba3f65f06d4919d4ae54d3f1a9da3c652f9e8a5b551e0700723f4ac44" name="abab34306ba3f65f06d4919d4ae54d3f1a9da3c652f9e8a5b551e0700723f4ac44"></a>DECOMP_READ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abab34306ba3f65f06d4919d4ae54d3f1ae2fa14b3e79878731d2d94369e0aa2a3" name="abab34306ba3f65f06d4919d4ae54d3f1ae2fa14b3e79878731d2d94369e0aa2a3"></a>DECOMP_PRIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abab34306ba3f65f06d4919d4ae54d3f1af7ce8bb8e6065228c3e34270131739f3" name="abab34306ba3f65f06d4919d4ae54d3f1af7ce8bb8e6065228c3e34270131739f3"></a>NO_DECOMP&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad049f9925bbec6f1e1b8097723c01d95" name="ad049f9925bbec6f1e1b8097723c01d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad049f9925bbec6f1e1b8097723c01d95">&#9670;&#160;</a></span>ImplemCond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95">LatMRG::ImplemCond</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of conditions are imposed on the coefficients \(a_i\) of a recurrence. </p>
<p><span class="tt">NO_COND</span>: no condition is imposed on the coefficients.<br  />
 <span class="tt">APP_FACT</span>: the coefficients must satisfy the "approximate
factoring" condition \(|a_i| (m\mod|a_i|) &lt; m\). Congruential generators are easier to implement under this condition <a class="el" href="../../d0/de3/citelist.html#CITEREF_rlec90a">[5]</a>&thinsp;.<br  />
 <span class="tt">POWER_TWO</span>: the coefficients must be sums or differences of powers of 2.<br  />
 <span class="tt">EQUAL_COEF</span>: all the coefficients must be equal by groups: a first group all equal to a first number, a second group all equal to a second number, and so on. <br  />
 <span class="tt">ZERO_COEF</span>: all the coefficients must be equal to 0, except for a select fews. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad049f9925bbec6f1e1b8097723c01d95ad9ab360d18c9302b90dd714d35a0c132" name="ad049f9925bbec6f1e1b8097723c01d95ad9ab360d18c9302b90dd714d35a0c132"></a>NO_COND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad049f9925bbec6f1e1b8097723c01d95adc39f6458d387d2cfc655b1f02d4f3d7" name="ad049f9925bbec6f1e1b8097723c01d95adc39f6458d387d2cfc655b1f02d4f3d7"></a>APP_FACT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad049f9925bbec6f1e1b8097723c01d95a3e31685740aafc4bef9f3508db0bec77" name="ad049f9925bbec6f1e1b8097723c01d95a3e31685740aafc4bef9f3508db0bec77"></a>POWER_TWO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad049f9925bbec6f1e1b8097723c01d95aa6f98d6ee60b601dd3f366499899cd67" name="ad049f9925bbec6f1e1b8097723c01d95aa6f98d6ee60b601dd3f366499899cd67"></a>EQUAL_COEF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad049f9925bbec6f1e1b8097723c01d95aff9dd7625c374d20ef6ba6a9bf5f0e12" name="ad049f9925bbec6f1e1b8097723c01d95aff9dd7625c374d20ef6ba6a9bf5f0e12"></a>ZERO_COEF&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1fd35b5cabbc11ccb440e722240ca3e8" name="a1fd35b5cabbc11ccb440e722240ca3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd35b5cabbc11ccb440e722240ca3e8">&#9670;&#160;</a></span>SearchMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1fd35b5cabbc11ccb440e722240ca3e8">LatMRG::SearchMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the search method used to find good multipliers \(a_i\). </p>
<p><span class="tt">EXHAUST</span>: the search will be exhaustive over the chosen regions.<br  />
 <span class="tt">RANDOM</span>: the search will be random over the chosen regions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1fd35b5cabbc11ccb440e722240ca3e8af348ef97764bf697a7be024947e10330" name="a1fd35b5cabbc11ccb440e722240ca3e8af348ef97764bf697a7be024947e10330"></a>EXHAUST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1fd35b5cabbc11ccb440e722240ca3e8a57df570a60b5ea66ef4a74640b026c8b" name="a1fd35b5cabbc11ccb440e722240ca3e8a57df570a60b5ea66ef4a74640b026c8b"></a>RANDOM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab24055f29985bdc83f514e803c4f7bda" name="ab24055f29985bdc83f514e803c4f7bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24055f29985bdc83f514e803c4f7bda">&#9670;&#160;</a></span>LacunaryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab24055f29985bdc83f514e803c4f7bda">LatMRG::LacunaryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the type of lacunary projection used in <span class="tt"><a class="el" href="../../da/d2c/classLatMRG_1_1MMRGLattice.html">MMRGLattice</a></span>: </p>
<ul>
<li>NONE: no lacunary projection</li>
<li>SUBVECTOR: only the selected coordinates of each new random vector are kept</li>
<li>ARBITRARYINDICES: only the selected indices are kept. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab24055f29985bdc83f514e803c4f7bdaace6d51c2ece6bb392ade633f25bcf9c2" name="ab24055f29985bdc83f514e803c4f7bdaace6d51c2ece6bb392ade633f25bcf9c2"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab24055f29985bdc83f514e803c4f7bdaab76e637b32947ec260a58def7b11b6b7" name="ab24055f29985bdc83f514e803c4f7bdaab76e637b32947ec260a58def7b11b6b7"></a>SUBVECTOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab24055f29985bdc83f514e803c4f7bdaa44a10b67651488cf044f3bdabad7fe15" name="ab24055f29985bdc83f514e803c4f7bdaa44a10b67651488cf044f3bdabad7fe15"></a>ARBITRARYINDICES&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a671c2035934701d0aad78ff85a41a11f" name="a671c2035934701d0aad78ff85a41a11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671c2035934701d0aad78ff85a41a11f">&#9670;&#160;</a></span>getLatCombo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int, typename Real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html">MRGLattice</a>&lt; Int, Real &gt; * LatMRG::getLatCombo </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MRGPeriod&lt; Int &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxDim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes and returns a <span class="tt"><a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html" title="This subclass of IntLatticeExt defines an MRG lattice and is similar to Rank1Lattice,...">MRGLattice</a></span> that is the lattice of the combination of generators described in the <span class="tt">MRGPeriod</span>s in the vector <span class="tt">comp</span>. </p>
<p>This dynamically allocates memory to returned pointer. and needs to be deleted afterwards. </p>

</div>
</div>
<a id="a46e2b79fe37f6b1e64552fe795a32a14" name="a46e2b79fe37f6b1e64552fe795a32a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e2b79fe37f6b1e64552fe795a32a14">&#9670;&#160;</a></span>getLatCombo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html">MRGLattice</a>&lt; std::int64_t, double &gt; * LatMRG::getLatCombo </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MRGPeriod&lt; std::int64_t &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxDim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30a18ac8dfd5ed29fedda9ca9d25eb33" name="a30a18ac8dfd5ed29fedda9ca9d25eb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a18ac8dfd5ed29fedda9ca9d25eb33">&#9670;&#160;</a></span>getLatCombo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="../../d6/d04/classLatMRG_1_1MRGLattice.html">MRGLattice</a>&lt; NTL::ZZ, NTL::RR &gt; * LatMRG::getLatCombo </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MRGPeriod&lt; NTL::ZZ &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxDim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa722e6aa0789707125e1505a97a18abb" name="aa722e6aa0789707125e1505a97a18abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa722e6aa0789707125e1505a97a18abb">&#9670;&#160;</a></span>toStringPrimeType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatMRG::toStringPrimeType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afac2b812b1032e05d3021526a3a0b63c">PrimeType</a></td>          <td class="paramname"><span class="paramname"><em>prime</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following are functions for printing the <span class="tt">enum</span> constants in this module. </p>
<p>Each function returns the value of the <span class="tt">enum</span> variable given as input as a string. </p>

</div>
</div>
<a id="a317cea9c7556eb472e6589f896d4e537" name="a317cea9c7556eb472e6589f896d4e537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317cea9c7556eb472e6589f896d4e537">&#9670;&#160;</a></span>toStringGenType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatMRG::toStringGenType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab4948e899f8c3a6fb82cff009283061e">GenType</a></td>          <td class="paramname"><span class="paramname"><em>gen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f1c234d3d916c8db4595998a9742e02" name="a0f1c234d3d916c8db4595998a9742e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1c234d3d916c8db4595998a9742e02">&#9670;&#160;</a></span>toStringLatticeType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatMRG::toStringLatticeType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a86edf8445f847038592d741fd49b2b09">LatticeType</a></td>          <td class="paramname"><span class="paramname"><em>lat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adabf852a26ad5fae6802ab50db439cec" name="adabf852a26ad5fae6802ab50db439cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabf852a26ad5fae6802ab50db439cec">&#9670;&#160;</a></span>toStringDecompType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatMRG::toStringDecompType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abab34306ba3f65f06d4919d4ae54d3f1">DecompType</a></td>          <td class="paramname"><span class="paramname"><em>decomp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f0a03ca1af239f9818b4f6ac3820b26" name="a5f0a03ca1af239f9818b4f6ac3820b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a03ca1af239f9818b4f6ac3820b26">&#9670;&#160;</a></span>toStringImplemCond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatMRG::toStringImplemCond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad049f9925bbec6f1e1b8097723c01d95">ImplemCond</a></td>          <td class="paramname"><span class="paramname"><em>implem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3aaab7957188b6822a58a1b668b9f05" name="ae3aaab7957188b6822a58a1b668b9f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3aaab7957188b6822a58a1b668b9f05">&#9670;&#160;</a></span>toStringSearchMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatMRG::toStringSearchMethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1fd35b5cabbc11ccb440e722240ca3e8">SearchMethod</a></td>          <td class="paramname"><span class="paramname"><em>searchm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a415796c7d63f465cede62fbdf9ba1d70" name="a415796c7d63f465cede62fbdf9ba1d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415796c7d63f465cede62fbdf9ba1d70">&#9670;&#160;</a></span>toStringLacunaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatMRG::toStringLacunaryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab24055f29985bdc83f514e803c4f7bda">LacunaryType</a></td>          <td class="paramname"><span class="paramname"><em>lacunary</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca6bf48506108b28ac831839120a7ab5" name="aca6bf48506108b28ac831839120a7ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6bf48506108b28ac831839120a7ab5">&#9670;&#160;</a></span>setModulusIntP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::setModulusIntP </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets to <span class="tt">m</span> the modulus used by NTL for its <span class="tt">IntP</span> calculations. </p>
<p>Sets to <span class="tt">p</span> the modulus used by NTL for its <span class="tt">IntP</span> calculations. </p>

</div>
</div>
<a id="a7202935548ae566ad85f3710bfefa548" name="a7202935548ae566ad85f3710bfefa548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7202935548ae566ad85f3710bfefa548">&#9670;&#160;</a></span>findPrime() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::findPrime </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span><span class="paramdefsep"> = </span><span class="paramdefval">200</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and prints the \(s\) largest prime integers \(m &lt; 2^e\). </p>

</div>
</div>
<a id="ae5afab0c8e00d159b6f5cbba1a5f328f" name="ae5afab0c8e00d159b6f5cbba1a5f328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5afab0c8e00d159b6f5cbba1a5f328f">&#9670;&#160;</a></span>findPrime() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::findPrime </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span><span class="paramdefsep"> = </span><span class="paramdefval">200</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the \(s\) largest prime integers \(m&lt;2^e\) for which \(r = (m^k-1)/(m-1)\) is also prime. </p>
<p>If <span class="tt">safe</span> is <span class="tt">true</span>, \((m-1)/2\) is also required to be prime. </p>

</div>
</div>
<a id="a612045696ae0d10586a43c0aa052d7f9" name="a612045696ae0d10586a43c0aa052d7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612045696ae0d10586a43c0aa052d7f9">&#9670;&#160;</a></span>findPrime() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::findPrime </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span><span class="paramdefsep"> = </span><span class="paramdefval">200</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all integers \(m\), in \(2^e + c_1 \le m \le 2^e + c_2\), such that \(m\) and \(r = (m^k-1)/(m-1)\) are prime. </p>
<p>If <span class="tt">safe</span> is <span class="tt">true</span>, \((m-1)/2\) is also required to be prime. </p>

</div>
</div>
<a id="a7942d3c5fd5b08b6313554c782c02235" name="a7942d3c5fd5b08b6313554c782c02235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7942d3c5fd5b08b6313554c782c02235">&#9670;&#160;</a></span>findPrime() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::findPrime </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span><span class="paramdefsep"> = </span><span class="paramdefval">200</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the general purpose function, called by the other ones. </p>
<p>It searches for the <span class="tt">s</span> largest prime integers between <span class="tt">S1</span> and <span class="tt">S2</span>. </p>

</div>
</div>
<a id="afa05d41c55fb8a6d08fccc838af7c1f1" name="afa05d41c55fb8a6d08fccc838af7c1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa05d41c55fb8a6d08fccc838af7c1f1">&#9670;&#160;</a></span>writeHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::writeHeader </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span><span class="paramdefsep"> = </span><span class="paramdefval">200</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the search parameters to the stream <span class="tt">fout</span>. </p>

</div>
</div>
<a id="ab566f101d19952cf7e4d88dd97e5167c" name="ab566f101d19952cf7e4d88dd97e5167c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab566f101d19952cf7e4d88dd97e5167c">&#9670;&#160;</a></span>nextM()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::nextM </td>
          <td>(</td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d42e8aeb4a56d55b039cf0f29b3231e" name="a8d42e8aeb4a56d55b039cf0f29b3231e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d42e8aeb4a56d55b039cf0f29b3231e">&#9670;&#160;</a></span>findPrime() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::findPrime </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span><span class="paramdefsep"> = </span><span class="paramdefval">200</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the general purpose function, called by the other ones. </p>
<p>It searches for the <span class="tt">s</span> largest prime integers between <span class="tt">S1</span> and <span class="tt">S2</span>. </p>

</div>
</div>
<a id="a84b942c989a2c5bacdd76daf9961a948" name="a84b942c989a2c5bacdd76daf9961a948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b942c989a2c5bacdd76daf9961a948">&#9670;&#160;</a></span>findPrime() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::findPrime </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and prints the \(s\) largest prime integers \(m &lt; 2^e\). </p>

</div>
</div>
<a id="a586ec61c87ad0672a9fd2ad02df6e475" name="a586ec61c87ad0672a9fd2ad02df6e475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586ec61c87ad0672a9fd2ad02df6e475">&#9670;&#160;</a></span>findPrime() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::findPrime </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span><span class="paramdefsep"> = </span><span class="paramdefval">200</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the \(s\) largest prime integers \(m&lt;2^e\) for which \(r = (m^k-1)/(m-1)\) is also prime. </p>
<p>If <span class="tt">safe</span> is <span class="tt">true</span>, \((m-1)/2\) is also required to be prime. </p>

</div>
</div>
<a id="a78bfd721e993605107bc9749a2834408" name="a78bfd721e993605107bc9749a2834408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bfd721e993605107bc9749a2834408">&#9670;&#160;</a></span>findPrime() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::findPrime </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>facto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>fout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>RMtrials</em></span><span class="paramdefsep"> = </span><span class="paramdefval">200</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all integers \(m\), in \(2^e + c_1 \le m \le 2^e + c_2\), such that \(m\) and \(r = (m^k-1)/(m-1)\) are prime. </p>
<p>If <span class="tt">safe</span> is <span class="tt">true</span>, \((m-1)/2\) is also required to be prime. </p>

</div>
</div>
<a id="a0a60e636843f69cfc80a35c8ac034d5f" name="a0a60e636843f69cfc80a35c8ac034d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a60e636843f69cfc80a35c8ac034d5f">&#9670;&#160;</a></span>isPrimitiveElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LatMRG::isPrimitiveElement </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This file provides static functions to test for the primitivity of an integer or a polynomial in a finite field. </p>
<p>Suppose that \(a\), \(e\), and \(p\) are integers, \(p\) is a prime number, and \(a\) is relatively prime with \(m=p^e\). The smallest positive integer \(\lambda(m,a)\) for which \(a^{\lambda(m,a)}= 1 \ \bmod\ m \) is called the order of \(a\) modulo \(m\). Any \(a\) which has the maximum possible order for a given \(m\) is called a primitive element modulo \(m\). The function <span class="tt">isPrimitiveElement</span> tests for this property.</p>
<p>The function <span class="tt">isPrimitive</span> tests for the primitivity of the characteristic polynomial of an MRG, with coefficients in \(\mathbb Z_m\). This is done by checking the conditions proposed by Alanen and Knuth <a class="el" href="../../d0/de3/citelist.html#CITEREF_mala64a">[1]</a>, and restated in <a class="el" href="../../d0/de3/citelist.html#CITEREF_slec23s">[6]</a> and in the <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> user's guide. The polynomial arithmetic is done using NTL. A polynomial <a class="anchor" id="REF__Primitivity_eq_poly1"></a>   </p><p class="formulaDsp">
\[  f(z) = c_0 + c_1 z^1 + \cdots + c_{k-1} z^{k-1} + c_k z^k    \tag{eq.poly1}
\]
</p>
<p> of degree \(k\) and integer coefficients \(c_j \in \mathbb Z_m\) is represented in NTL by the vector \((c_0,c_1,\dots,c_k)\) of its coefficients, which is directly accessible. The characteristic polynomial of an MRG, usually written as <a class="anchor" id="REF__Primitivity_eq_poly2"></a>   </p><p class="formulaDsp">
\[  P(z) = z^k - a_1 z^{k-1} - \cdots- a_{k-1} z - a_k,   \tag{eq.poly2}
\]
</p>
<p> must be put in the form <code><a class="el" href="#REF__Primitivity_eq_poly1">(eq.poly1)</a></code> to use NTL. It has \(c_k=1, $c_{k-1}= -a_1\f, \cdots, c_1 = -a_{k-1}, c_0 = - a_k\).</p>
<p>We recall that the polynomial \(f(z)\) in <code><a class="el" href="#REF__Primitivity_eq_poly1">(eq.poly1)</a></code> with \(c_k=1\) is primitive modulo \(m\) if and only if the three following conditions are satisfied: <a class="anchor" id="REF__Primitivity_isprimi"></a></p><dl>
<dt>None </dt>
<dd>\([(-1)^{k} c_0]^{(m-1)/q} \bmod m \neq1\) for each prime factor \(q\) of \(m - 1\);  </dd>
<dt>None </dt>
<dd>\(z^r \bmod(f(z),m) =  (-1)^{k} c_0 \bmod m\);  </dd>
<dt>None </dt>
<dd>\(z^{r/q} \bmod(f(z), m) \) has positive degree for each prime factor \(q\) of \(r\), with \(1&lt;q&lt; r\);  </dd>
</dl>
<p>where \(r = (m^k - 1)/(m - 1)\). Condition 1 is the same as saying that \((-1)^{k} c_0\) is a primitive root of \(m\). Condition 3 is automatically satisfied when \(r\) is prime.</p>
<p>The types used for the polynomial coefficients in depend on the choice of <span class="tt">Int</span> and are determined by the template class <span class="tt"><a class="el" href="../../d6/da9/FlexModInt_8h.html">FlexModInt.h</a></span>. The function <span class="tt">isPrimitiveElement</span> does no use <span class="tt"><a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html" title="The FlexModInt class permits one to use the NTL functions that work on integers, vectors,...">FlexModInt</a></span>. Returns <span class="tt">true</span> iff <span class="tt">a</span> is a primitive element modulo \(p^e\), where \(p\) is assumed to be a prime number. The prime factor decomposition of \(p-1\) must be given in <span class="tt">fac</span>, and the list of inverse factors in <span class="tt">fac</span> must be up to date.</p>
<p>This file provides static functions to test for the primitivity of an integer or a polynomial in a finite field. </p>

</div>
</div>
<a id="a5c87d7b433d4c7463eff0676b949d5fb" name="a5c87d7b433d4c7463eff0676b949d5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c87d7b433d4c7463eff0676b949d5fb">&#9670;&#160;</a></span>isPrimitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LatMRG::isPrimitive </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> iff the polynomial \(f\) is a primitive polynomial modulo \(m\). </p>
<p>The factorizations of \(m-1\) and \(r\) must be in <span class="tt">fm</span> and <span class="tt">fr</span> respectively. The modulus <span class="tt">m</span> should be set before, via the <span class="tt">setModulusIntP</span> function from <span class="tt"><a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html" title="The FlexModInt class permits one to use the NTL functions that work on integers, vectors,...">FlexModInt</a></span>. </p>

</div>
</div>
<a id="a9528f80c9264d3a72fec99dc016bac3e" name="a9528f80c9264d3a72fec99dc016bac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9528f80c9264d3a72fec99dc016bac3e">&#9670;&#160;</a></span>isPrimitive23()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LatMRG::isPrimitive23 </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <span class="tt">isPrimitive</span> above, except that this function only checks for Conditions 2 and 3. </p>
<p>Condition 1 is assumed to hold. </p>

</div>
</div>
<a id="ace6e9031b7cd981bc36c0ee69ab27aea" name="ace6e9031b7cd981bc36c0ee69ab27aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6e9031b7cd981bc36c0ee69ab27aea">&#9670;&#160;</a></span>setCharacPoly() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::setCharacPoly </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the coefficients of the polynomial <span class="tt">f</span> so it corresponds to the characteristic polynomial \(P(z) = z^k - a_1 z^{k-1} - \cdots- a_{k-1} z - a_k\) with coefficients \(c_{k-j} = a_j = \)<span class="tt">aa[j]</span>. </p>
<p>The modulus used in <span class="tt">IntP</span> is assumed to be correct, this is not verified. </p>

</div>
</div>
<a id="af02c4541e113a9fc821da559d63ac0b0" name="af02c4541e113a9fc821da559d63ac0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02c4541e113a9fc821da559d63ac0b0">&#9670;&#160;</a></span>setCharacPoly() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::setCharacPoly </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::IntVecP &amp;</td>          <td class="paramname"><span class="paramname"><em>aaP</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In this version, the vector of coefficients is passed directly as an <span class="tt">IntVecP</span>, so there is no need to convert it internally (this is more efficient). </p>

</div>
</div>
<a id="a449fc348bca5c3d64f14a8f60c862d81" name="a449fc348bca5c3d64f14a8f60c862d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449fc348bca5c3d64f14a8f60c862d81">&#9670;&#160;</a></span>vecMRGToPoly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::vecMRGToPoly </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::IntVecP</td>          <td class="paramname"><span class="paramname"><em>aaP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>xx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the vector state <span class="tt">xx</span> of an MRG to its polynomial representation in <span class="tt">f</span>. </p>
<p>The vector of coefficients of the MRG is passed in <span class="tt">aa</span> and the modulus used in <span class="tt">IntP</span> is assumed to be the correct one. The vector <span class="tt">xx</span> is assumed to contain the vector state \((x_{n-k+1,\dots,x_n)\) with <span class="tt">xx[j]</span> \(x_{n-k+1+j]\). The polynomial <span class="tt">f</span> will have degree <span class="tt">k-1</span> or less. </p>

</div>
</div>
<a id="a80797562d84af6a39970188ffb870675" name="a80797562d84af6a39970188ffb870675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80797562d84af6a39970188ffb870675">&#9670;&#160;</a></span>polyToVecMRG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::polyToVecMRG </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>xx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::IntVecP</td>          <td class="paramname"><span class="paramname"><em>aaP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the polynomial representation in <span class="tt">f</span> to the vector state <span class="tt">xx</span> of an MRG, with <span class="tt">xx[j]</span> \(x_{n-k+1+j]\). </p>
<p>The polynomial <span class="tt">f</span> must have degree <span class="tt">k-1</span> or less. The vector of coefficients of the MRG is passed in <span class="tt">aa</span> and the modulus used in <span class="tt">IntP</span> is assumed to be the correct one. </p>

</div>
</div>
<a id="a5809a59baeaac412e2819b5388c4cd51" name="a5809a59baeaac412e2819b5388c4cd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5809a59baeaac412e2819b5388c4cd51">&#9670;&#160;</a></span>isPrimitiveElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatMRG::isPrimitiveElement </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d6c/classLatMRG_1_1IntFactorization.html">IntFactorization</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in <span class="tt">fj</span> the polynomial \(x^j \mod f(x) (\bmod m)\) where \(f(x)\) is the polynomial with coefficients in 'C', modulo 'm'. </p>
<p>This file provides static functions to test for the primitivity of an integer or a polynomial in a finite field. </p>

</div>
</div>
<a id="a612afc59cdc99759cfcc088f5cc12be5" name="a612afc59cdc99759cfcc088f5cc12be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612afc59cdc99759cfcc088f5cc12be5">&#9670;&#160;</a></span>setCharacPoly() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatMRG::setCharacPoly </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::PolX &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="../../da/db0/classLatMRG_1_1FlexModInt.html">FlexModInt</a>&lt; Int &gt;::IntVecP</td>          <td class="paramname"><span class="paramname"><em>aaP</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ad56a743819a7b2ab0ae95fae3c97d9a3" name="ad56a743819a7b2ab0ae95fae3c97d9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56a743819a7b2ab0ae95fae3c97d9a3">&#9670;&#160;</a></span>NB_PRIMES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t LatMRG::NB_PRIMES = 6543</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32bf71856a2c14d79708d3ccfff94985" name="a32bf71856a2c14d79708d3ccfff94985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bf71856a2c14d79708d3ccfff94985">&#9670;&#160;</a></span>PRIMES_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;uint64_t, <a class="el" href="#ad56a743819a7b2ab0ae95fae3c97d9a3">NB_PRIMES</a>&gt; LatMRG::PRIMES_ARRAY</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line"> </div>
<div class="line">      }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <a href="https://github.com/pierrelecuyer/latmrg">Available on Github</a>
    <li class="navelem"><a href="../../df/d5e/namespaceLatMRG.html">LatMRG</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
