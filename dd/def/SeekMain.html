<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatMRG API Documentation: SeekMain</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatMRG API Documentation<span id="projectnumber">&#160;unknown</span>
   </div>
   <div id="projectbrief">Tools to analyze the lattice structure of linear generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/def/SeekMain.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SeekMain</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="seek"></a>
SeekMain</h1>
<p>This is the main program to search for the "best" (or "worst") multiple recursive generators of a given form, based on a criteria based on the Beyer quotient or on the spectral test. It produces a report listing the retained generators, their properties, and various statistics on the search.</p>
<p>One can search for combined MRGs with \(J\) components, or simple MRGs \((J=1)\). For a single MRG (or for each component, in case \(J &gt; 1\)), with given modulus \(m\) and order \(k\), the program searches for vectors of multipliers inside the region bounded by the vectors \(b = (b_1,…,b_k)\) and \(c = (c_1,…,c_k)\) such that  \(-m &lt;
b_i\le c_i &lt; m\) for each \(i\). The search can be exhaustive in that region, or random. One can search only among maximal period generators (for each component), or not consider the period and examine only the lattice structure. The former (checking maximal period conditions) can be done only if \(m\) is prime, or if \(k=1\) and \(m\) is a power of a prime. The program can also list the retained generators in a file, in a format more compact than the standard one that can be re-used as input to the program, in a later run. This could be useful, for example, if one wishes to perform first a screening over a large region, based on a criterion that does not require expensive computations, and then do a second pass over the retained generators, based on a more stringent criterion, such as looking at the lattice structure in higher dimensions, and/or verifying the results by performing all computations using error bounds.</p>
<h2><a class="anchor" id="method_seek"></a>
Searching method</h2>
<p>For an exhaustive search for MRGs, all vectors of multipliers of the form \(a = (a_1,…,a_k)\) such that \(b_i\le a_i\le c_i\) for \(i=1,…,k\) will be examined, for a total of \(N_v = \prod_{i=1}^k (c_i-b_i+1)\) vectors. This holds for each component. Therefore, if there are \(J\) components and \(N_{v,j}\) vectors are examined for component \(j\), then a total of \(\prod_{j=1}^J N_{v,j}\) generators are examined.</p>
<p>For a random search for MRGs, we fix a number of subregions (clusters) we want to examine, and the size \(h_i\) of each subregion in dimension \(i\), for \(i=1,…,k\). The program will examine a total of \(n\prod_{i=1}^k h_i\) vectors of multipliers (for each MRG component) by repeating \(n\) times the following: For \(i=1,…,k\), generate \(\alpha_i\) randomly, uniformly over the set \(\{b_i,…,c_i-h_i+1\}\); then, examine all the vectors  \(a =
(a_1,…,a_k)\) such that \(\alpha_i\le a_i\le\alpha_i+h_i-1\) for each \(i\).</p>
<p>When examining a vector \(a\), the program first checks if the maximal period conditions are satisfied, if this is required. For prime modulus \(m\), the condition </p><p class="formulaDsp">
\[((-1)^{k+1} a_k)^{(m-1)/q}\ \mathrm{mod} \ m \neq 1,\ \forall q | m-1\]
</p>
<p> is verified only once for each distinct value of \(a_k\) (which corresponds to \(\prod_{i=1}^{k-1} h_i\) different values). To verify the maximal period conditions, the factorizations of \(m-1\) and  \(r =
(m^k-1)/(m-1)\) are required. They can be found by the program, if desired, or provided by the user in a file (see below). All factorizations depend on the inclusion of the <code>yafu</code> executable in the right path. More information is provided about that in the installation instructions. Factoring \(r\) can take <em>huge</em> amounts of time. To avoid redoing the factorization, it is possible to print the factorization results in a file. The factorizations of \(m-1\) et \(r\) are necessary only when \(m\) is prime and maximal period is required.</p>
<p>If \(a\) is not rejected by the maximal period test, then we move forward to the next MRG component and try all the vectors for that next component (by exhaustive or random search) and examine their combination with the currently examined multipliers for the previous components. For each combined generator, the values of \(d_t\) or \(q_t\) are computed for dimensions \(k+1,…,T\).</p>
<p>The program always keeps lower and upper bounds on the figure of merit ( \(M_T\) or \(Q_T\)), in each dimension, for the generator to be worth considering. The initial values of these bounds are given by the user in the fields <em>MinMerit</em> and <em>MaxMerit</em>. The lower bound can be 0.0 and the upper bound can be 1.0, which means that there is no effective bounds for some categories if desired.</p>
<p>As soon as a generator has a figure of merit below the lower bound in a given dimension, or above the upper bound for its category (after the computations for all the dimensions in this category have been completed), then this generator is immediately discarded and no further computations are made for it. This can save enormous amounts of time in the case of very large searches up to high dimensions, because with good bounds, few generators will reach the large dimensions.</p>
<p>During execution, only the bounds for the last category can be modified. If the figure of merit for the last category is to be <em>maximized</em>, when we have found enough [i.e., <em>NbGen</em>( \(C\))] generators with a figure of merit \(\ge\sigma\), where \(\sigma\) is larger than the lower bound for the last category, then we raise this lower bound to \(\sigma\). Similarly, if we minimize in the last category, we can lower the upper bound when we have enough generators beating the bound. In the case where the figure of merit is to be <em>maximized in all</em> the categories, then a generator is also discarded as soon as its figure of merit in <em>any</em> dimension gets below the lower bound of the last category.</p>
<p>The set of dimensions in which the test is applied can be partitioned into a certain number of intervals, or categories, and one can use a different selection criterion for the generators within each category. One can also impose bounds on the figure of merit within each category: see the data fields for <code>C</code>, <code>MinMerit</code> and <code>MaxMerit</code> below. For example, one can consider only the generators with \(M_8 \ge 0.6\), and, among these, retain the list of generators with the smallest value of \(M_{12}\). As another example, one can retain the 2 generators with the highest \(M_8\), the 2 generators with the highest \(M_{16}\) and the eight generators with the highest \(M_{32}\).</p>
<p>The execution (CPU) time is checked before testing each new generator. When it exceeds the CPU time limit given in the data file, the search is aborted and the partial results are printed.</p>
<h2><a class="anchor" id="executable_seek"></a>
The executable programs</h2>
<p>Three different executable programs are compiled by the <code>makefile</code> from <code>SeekMain</code>. Each of those executable uses a different types combination :</p><ul>
<li><code>SeekLLDD</code> uses the standard C++ <code>int64_t</code> and <code>double</code> to represent every number needed by the program. This is the recommended parameter for small applications/testing implementations as it is the fastest one.</li>
<li><code>SeekZZDD</code> uses <code>NTL::ZZ</code> to represent integers in the basis of the lattices, but uses <code>double</code> to represent and make computation of vector length/figures of merit. This parameter is best used when doing <code>real scale</code> applications, when searching for 64-bit MRGs for example.</li>
<li><code>SeekZZRR</code> uses both <code>NTL::ZZ</code> for integers and <code>NTL::RR</code> for floating point numbers. This is only usefull when testing a small set of generators or when testing generators with an absurdly big modulo (which could happen when testing MWC generators for example). The <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> module <code>Types</code> includes a comprehensive guide on how to choose the types depending on the use case.</li>
</ul>
<h2><a class="anchor" id="data_seek"></a>
The data file</h2>
<p><a class="anchor" id="input_format_seek"></a></p><pre class="fragment"> Criterion [Normalizer]
 ReadGenFile [GenFile]
 J
 GenType                             // This section has to appear J times
 m                                   //
 k                                   //
 PerMax                              //
 F1 [filem]                          //
 F2 [filer]                          //
 ImplementCond [s k[1] ... k[s]]     //
 b_1                                 //
 c_1                                 //
 .                                   //
 .                                   //
 .                                   //
 b_k                                 //
 c_k                                 //
 SearchMethod [n H H_k]              //
 C
 MinMerit[1], ..., MinMerit[C]
 MaxMerit[1], ..., MaxMerit[C]
 NbGen[1], ..., NbGen[C]
 d
 t[0], ..., t[d]
 WithDual
 Speed
 LatticeType
 LacGroupSize LacSpacing
 MaxNodesBB
 Duration Unit
 S
 OutputType
</pre> <center> <b>Data file format for <code>SeekMain</code></b> </center><p>The data for <code>SeekMain</code> must be placed in a file with extension <code>.dat</code>, according to the format displayed <a class="el" href="#input_format_seek">above</a>. The fields in square brackets are optional (depending on the value taken by the first field on the line). The meaning of all data fields is explained below. To run the program, type <code>./bin/SeekMain /path/to/file</code>, where <code>/path/to/file.dat</code> is the name of the data file containing the test to execute. The results will be printed either in a file <code>/path/to/file.res</code> or <code>path/to/file.gen</code> depending on <code>OutpoutType</code> (see below).</p>
<p>The values of \(m\), \(b_i\), and \(c_i\) in the data file can be given in one of the two following formats:</p>
<ol type="1">
<li>An integer giving the value directly, in base 10. In this case, there <em>must</em> be some other non-numeric text (e.g., a comment) on this data line after the integer.</li>
<li>Three integers \(x\), \(e\), and \(z\) on the same line, separated by at least one blank. The retained value will be \(x^e+z\) if \(x\ge0\), and \(-(|x|^e+z)\) if \(x&lt;0\). The value of \(e\) must be positive. For example, <code>[x e z] = [2 5 -1]</code> will give <code>31</code>, while <code>[x e z] = [-2 5 -1]</code> will give <code>-31</code> (not <code>-33</code>).</li>
</ol>
<p>If the types chosen are LLDD, then the numbers used here must fit in a 64 bits integers. In the other cases, it won't matter.</p>
<h2><a class="anchor" id="fields_seek"></a>
Meaning of the data fields</h2>
<p>We explain the meaning of all the fields of the data file. For every line, of the data file, the options for the mandatory fields are listed between inequality signs as <code>&lt;option1, option2, ...&gt;</code> while the options for the optionnal/situationnal fields are listed in square brackets as <code>[option1, option2, ...]</code>.</p>
<dl>
<dt>Criterion Normalizer : </dt>
<dd><p class="startdd"><code>&lt;Beyer, Spectral&gt; [BestLat, Laminated, Rogers, Minkowski, MinkL1]</code> <br  />
Criterion specifies the merit criterion for ranking the generators for each category. If Criterion is <code>Spectral</code>, then <em>Normalizer</em> must appear and it indicates which type of normalization is used in the definition of \(M_T\). The admissible values are</p>
<dl>
<dt><code>Beyer</code>: </dt>
<dd>means that the criterion is \(Q_T\) (the Beyer quotient). The program will retain the generators with the largest (or smallest) \(Q_T\) in each category. In that case, the <em>Normalizer</em> field may be blank and is unread.  </dd>
<dt><code>Spectral</code>: </dt>
<dd>means that the criterion is \(M_T\) (the Spectral test). The program will retain the generators with the largest values (or smallest) \(M_T\) in each category. In that case, the <em>Normalizer</em> field must appear.  </dd>
</dl>
<dl>
<dt><code>BestLat</code>: </dt>
<dd><p class="startdd">means that we use for \(d_t^*\) the value of \(d_t\) that corresponds to the best lattice in dimension \(t\). Only values for \(t\le48\) are known.</p>
<p class="enddd">This is the recommended parameter.  </p>
</dd>
<dt><code>Laminated</code>: </dt>
<dd>means that we use for \(d_t^*\) the value of \(d_t\) that corresponds to the best laminated lattice in dimension \(t\). Only values for \(t\le48\) are known.  </dd>
<dt><code>Rogers</code>: </dt>
<dd>means that \(d_t^*\) is obtained from Rogers’ bound.  </dd>
<dt><code>Minkowski</code>: </dt>
<dd>means that we use for \(d_t^*\) Minkowski’s theoretical bounds on the length of the shortest nonzero vector in a lattice. Only values for \(t\le48\) have been precomputed.  </dd>
<dt><code>MinkL1</code>: </dt>
<dd>means that length of vectors is computed using the \({\mathcal{L}}_1\) norm. Here, the length of the shortest nonzero vector gives the minimal number of hyperplanes that cover all the points of the lattice. Only values for \(t\le48\) have been precomputed.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt>ReadGenFile Genfile: </dt>
<dd><p class="startdd"><code>&lt;true, false&gt; [filename]</code> <br  />
<code>boolean</code> and file name (without extension). When <em>ReadGenFile</em> is <code>false</code>, the search is made according to the values of the fields below. When it is <code>true</code>, the generators to be looked at are those listed in the file <code>filename.gen</code>. This must be a file of type <code>.gen</code>, produced by this program with the <code>GEN</code> option for the <code>OutputType</code> data field. In that case, only those generators listed in that file are examined and the vectors \(b\) and \(c\) below are not used. </p>
<p class="enddd"></p>
</dd>
<dt>J: </dt>
<dd><p class="startdd"><code>&lt;int&gt;</code><br  />
Number of components of the generator. Must be an integer  \(J &gt;
0\). When \(J = 1\) we look for a single generator, and when \(J &gt; 1\), we look for combined generators. </p>
<p class="enddd"></p>
</dd>
<dt><code>GenType</code>: </dt>
<dd><p class="startdd"><code>&lt;MRG, KOROBOV, RANK1&gt;</code><br  />
The type of generator to build for this component. </p><dl>
<dt><code>MRG</code>: </dt>
<dd>means that this component is an MRG.  </dd>
<dt><code>KOROBOV</code>: </dt>
<dd>means that this component is a Korobov lattice.  </dd>
<dt><code>RANK1</code>: </dt>
<dd>means that this component is a rank 1 lattice.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt>m: </dt>
<dd><p class="startdd"><code>&lt;int&gt;</code><br  />
Modulus of the recurrence for this component. Must be positive a integer. If <code>m &gt;= 2^64</code> <code>SeekZZDD</code> or <code>SeekZZRR</code> have to be used. </p>
<p class="enddd"></p>
</dd>
<dt>k: </dt>
<dd><p class="startdd"><code>&lt;k&gt;</code><br  />
Order of the recurrence for this component. Must be a positive integer. Must be odd if the generator has to have a full period. For  \(m^k
&gt;= 2^{50}\), use the program <code>SeekZZDD</code> instead of <code>seekLLDD</code>. </p>
<p class="enddd"></p>
</dd>
<dt>Permax: </dt>
<dd><p class="startdd"><code>&lt;true, false&gt;</code><br  />
<code>boolean</code> variable. <code>true</code> if maximal period is required, <code>false</code> otherwise. When set to <code>true</code>, \(m\) must be expressed in the data file in the form 1: <code>[x e z]</code>, otherwise <em>Permax</em> will be put back to <code>false</code>. The software assumes that \(m\) is prime, unless \(z=0\) and \(e &gt; 1\), in which case it assumes that \(x\) is prime. In the latter case, one must have \(k=1\), otherwise <em>Permax</em> will be set back to <code>false</code>. </p>
<p class="enddd"></p>
</dd>
<dt>F1 filem: </dt>
<dd><p class="startdd"><code>&lt;Decomp, Write, Read&gt; [filename]</code><br  />
This line of data (and also the following one) is used only if maximal period is required and <code>m</code> is assumed to be prime (see the <code>Permax</code> field). Otherwise, the program just skips it (but the line must be there). <code>F1</code> indicates how the factors of <code>m-1</code> are to be found and <code>filename</code> is a file name without extension.</p>
<dl>
<dt><code>Decomp</code>: </dt>
<dd>means that the program itself will factorize <code>m-1</code>. In this case, the field <code>filem</code> is not used and can be omitted. Make sure that the <code>yafu</code> executable has been included when compiling if using this option. The factorization is done with no CPU time limit: it is the responsibility of the user to make sure that the factorization will take a reasonable amount of time.  </dd>
<dt><code>Write</code>: </dt>
<dd>means the same as <code>Decomp</code>, except that the program will also write the prime factors found in a file called <code>filename.fac</code>, one factor per line, with its multiplicity.  </dd>
<dt><code>Read</code>: </dt>
<dd>indicates that <code>m-1</code> is already factorized and that the factors will be read from file <code>filename</code>, in the same format. The factors need not be sorted, but must be one per line, each with its multiplicity, as described in method <code>read</code> of class <code>IntFactorization</code>. The factorization must be complete and the program will check if the product of all the factors is really equal to <code>m-1</code>.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt>F2 filer: </dt>
<dd><p class="startdd"><code>&lt;Decomp, Write, Read, Prime&gt; [filename]</code><br  />
This data line is similar to the previous one, except that it concerns <code>r=(m^k-1)/(m-1)</code> instead of <code>m-1</code>. In this case, it is possible that <code>r</code> be prime when <code>m</code> is prime (in contrast to <code>m-1</code> which is even in that case). Therefore, the additional value <code>Prime</code> is allowed for <code>F2</code>.</p>
<dl>
<dt><code>Prime</code>: </dt>
<dd>indicates that <code>r</code> is prime. Some piece of software must have been used independently to verify that <code>r</code> is indeed prime when using this option.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt>ImplemCond \(s\) \(k_1\) \(k_2\) … \(k_s\): </dt>
<dd><p class="startdd"><code>&lt;NoCond, AppFact, PowerTwo, NonZero, Equal&gt; [s k[1] ... k[s]]</code><br  />
Imposes different restrictions on the multipliers \(a_i\).</p>
<dl>
<dt><code>NoCond</code>: </dt>
<dd>no condition is imposed on the multipliers \(a_i\).  </dd>
<dt><code>AppFact</code>: </dt>
<dd>the multipliers must satisfy the condition \(|a_i| (m\mod|a_i|) &lt; m\), called "approximate factoring", for each \(i\). MRGs are often easier to implement under this condition <b>[rLEC90a]</b>&thinsp;.  </dd>
<dt><code>PowerTwo</code> \(s\) \({k_1}\): </dt>
<dd>the positive integers <em>s = NumPow2</em> and <em> \(k_1\) = HighestBit</em> must appear and they indicate that for each \(i\), the multiplier \(a_i\) must be the sum of at most <em>s</em> (positive or negative) powers of 2, with the highest power of 2 not exceeding \(2^{k_1}\) in absolute value. For example, if <em>s</em> = 2 and <em> \(k_1\)</em> = 30, there are \(30 \times31 /2\) possibilities for choosing the 2 powers of 2 and 4 possibilities for choosing their signs, yielding 1860 cases where \(a_i\) is obtained from exactly 2 powers of 2. If one adds the \(62\) cases where \(a_i\) is \(\pm\) a power of 2, this gives a total of 1922 possibilities for \(a_i\). In the case of <code>PowerTwo</code>, the bounds \(b_j\) and \(c_j\) on the multipliers (see below) are automatically reset to \(b_j = -(2^{e+1}-1)\) and \(c_j = 2^{e+1}-1\).  </dd>
<dt><code>NonZero</code> \(s\) \({k_1}\) \({k_2}\) \(\cdots\) \({k_s}\): </dt>
<dd>(note: \({k_s}\) must be equal to \(k\)) all the multipliers will be equal to 0, except for \(s\) of them: the \(s\) non-zero multipliers are \(a_{k_1}\), \(a_{k_2}\), …, \(a_{k_s}\). For example, for a MRG of order \(k=10\), the line <code>"NonZero 4 2 5 8 10"</code> will consider only vector of multipliers of the form  \(\mathbf{a} = (0, \alpha, 0, 0,
\beta, 0, 0, \gamma, 0, \delta)\) where \(\alpha, \beta, \gamma, \delta\) are arbitrary integers in their respective interval \([b_i, c_i]\). ( \(\mathbf{a_0}\) is unused). In that case, only \(s\) pairs \([b_i, c_i]\) must appear in the lines for \([b_i, c_i]\) below.  </dd>
<dt><code>Equal</code> \(s\) \({k_1}\) \({k_2}\) \(\cdots\) \({k_s}\): </dt>
<dd>(note: \({k_s}\) must be equal to \(k\)) all the multipliers must be equal by groups. There are \(s\) groups: the first group of \(k_1\) multipliers are all equal, the second group of \(k_2 - k_1\) multipliers are all equal, and so on until the last group of \((k - k_{s-1})\) multipliers which are all equal. \(k_j\) is the vector index of the last element of group \(j\). For example, for a MRG of order \(k=10\), the line <code>"Equal 4 2 5 8 10"</code> will consider only vector of multipliers of the form  \(\mathbf{a} =
(\alpha, \alpha, \beta, \beta, \beta, \gamma, \gamma, \gamma, \delta, \delta)\) where \(\alpha, \beta, \gamma, \delta\) are arbitrary integers in their respective interval \([b_i, c_i]\). ( \(\mathbf{a_0}\) is unused). Elements \(a_3 = a_4 =a_5\) are the elements of the second group. In that case, only \(s\) pairs \([b_i, c_i]\) must appear in the lines for \([b_i, c_i]\) below.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt><code>b_i</code>: </dt>
<dd><p class="startdd"><code>&lt;int&gt;</code><br  />
The \(b_i\) are integers such that  \(-m &lt; b_i \le c_i &lt;
m\) for \(i=1,…,k\). They determine the boundary of the (rectangular) area of search. This field goes along with the next one. </p>
<p class="enddd"></p>
</dd>
<dt><code>c_i</code>: </dt>
<dd><p class="startdd"><code>int</code><br  />
The \(c_i\) are integers such that  \(-m &lt; b_i \le c_i &lt;
m\) for \(i=1,…,k\). They determine the boundary of the (rectangular) area of search. </p>
<p class="enddd"></p>
</dd>
<dt>SearchMethod \(n,H,H_k\): </dt>
<dd><p class="startdd"><code>&lt;Exhaust, Random&gt; [n H Hk]</code><br  />
</p><dl>
<dt><code>Exhaust</code>: </dt>
<dd>means that the search will be exhaustive over the whole region determined by \(b\) and \(c\). The other parameters of this line are then unused and can be omitted.  </dd>
<dt><code>Random</code>: </dt>
<dd>asks for a random search. The integer \(n\) gives the number of subregions (clusters) to examine. \(H\) determines the size of these subregions, except for the \(k\)th element of the vector \(h\), where \(H_k\) determines the size. The vector \(h=(h_1,…,h_k)\) is computed by the program as follows: \(h_i = \min(H, c_i-b_i+1), i=1,…,k-1\), and \(h_k = \min(H_k, c_k-b_k+1)\). The random search is then executed as specified above.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt><code>C</code>: </dt>
<dd><p class="startdd"><code>&lt;int&gt;</code><br  />
The program will retain <code>C &gt;= 1</code> lists (or categories) of generators, according to the specifications given below. </p>
<p class="enddd"></p>
</dd>
<dt><code>MinMerit[1] ... MinMerit[C]</code>: </dt>
<dd><code>&lt;double ... double&gt;</code> </dd>
<dt><code>MaxMerit[1] ... MaxMerit[C]</code>: </dt>
<dd><p class="startdd"><code>&lt;double ... double&gt;</code></p>
<p class="interdd">Real numbers that must satisfy <code>0.0 &lt;= MinMerit[i] &lt;= MaxMerit[i] &lt;= 1.0</code> for each <code>i</code>, and <code>MinMerit[i] &lt;= MaxMerit[i-1]</code> for <code>i &gt; 1</code>. They represent the minimal and maximal values of the figure of merit <code>sigma</code> (specified by <code>Criterion</code> above and <code>d</code> and <code>t[0], ..., t[d]</code> below) to keep a generator for each category. That is, only the generators that satisfy <code>MinMerit[i] &lt;= sigma &lt;= MaxMerit[i]</code> are considered for the category <code>i</code> and the categories above it. Note that because of this, the values of <code>MinMerit[i]</code> should always be nondecreasing in <code>i</code>, because the lower bounds for all the previous categories also apply to any given category. As soon as a generator does not satisfy this criterion in a given dimension delimiting a category, it is discarded and no more time is spent to test it. When looking for good generators, one normally sets <code>MaxMerit[i]</code> to 1.0 for each <code>i</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>These parameters is currently broken and <code>C</code> should be kept at 1. <b>Marc-Antoine</b>: selon l'implémentation actuelle, c'est brisé. Présentement, le programme ne permet pas non plus de chercher des générateurs avec de mauvaises figures de mérite. Chaque intervalle devrait correspondre à un critère différent. </dd></dl>
</dd>
<dt><code>NbGen[1] ... NbGen[C]</code>: </dt>
<dd><p class="startdd"><code>&lt;int ... int&gt;</code><br  />
Each <code>NbGen[i]</code> must be an integer <code>&gt;= 0</code>. If positive: maximum number of generators to retain in the results for category <code>i</code>. The value 0 means that no list of generators is retained for that category. </p>
<p class="enddd"></p>
</dd>
<dt><code>d</code>: </dt>
<dd><p class="startdd"><code>&lt;int&gt;</code><br  />
An integer <code>&gt; 0</code> indicating what projections to test. If <code>d = 1</code>, only projections of successive coordinates in dimensions from <code>td[0]</code> to <code>td[1]</code> are tested. If <code>d &gt; 1</code> then all dimensions from <code>td[0]</code> to <code>td[1]</code> are tested with successive coordinates, then all i dimensional projection are tested with coordinates between <code>td[0]</code> and <code>td[i]</code> up to <code>d</code> dimensional projections. </p>
<p class="enddd"></p>
</dd>
<dt><code>t[0] ... t[d]</code>: </dt>
<dd><p class="startdd"><code>&lt;int ... int&gt;</code><br  />
The projections used to compute the figure of merit in dimension <code>1 &lt;= l &lt;= d</code> are all the subsets of dimension <code>l</code> of indices between <code>t[0]</code> and <code>t[l]</code>. </p>
<p class="enddd"></p>
</dd>
<dt><code>WithDual</code>: </dt>
<dd><p class="startdd"><code>&lt;true, false&gt;</code><br  />
If <code>true</code> the test is done for the dual lattice; otherwise for the primal lattice. </p>
<p class="enddd"></p>
</dd>
<dt><code>Speed</code>: </dt>
<dd><p class="startdd"><code>&lt;0, 1, 2&gt;</code><br  />
This data field currently is only used in the case of the spectral test, only if <code>d == 1</code>. It specifies if the spectral test should be accelerated by not doing the Branch-and-Bound algorithm. This can be usefull when doing a large scale search: the program will still be able to retain certain generators, with slightly worse figures of merit than their real values. After the search is done and generators have been retained, they can be tested more extensively by using the setting <code>0</code>.</p>
<dl>
<dt>0: </dt>
<dd>When this option is selected, the program executes normally.  </dd>
<dt>1: </dt>
<dd>When this option is selected, the figures of merit will only be computed with BKZ pre-reduction. The Branch-and-Bound will not be executed. The figures of merit will no longer be exact, but this can speed up the computations by a lot.  </dd>
<dt>2: </dt>
<dd>This does the same as the previous option but uses LLL pre-reduction instead of BKZ pre-reduction.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt><code>LatticeType</code>: </dt>
<dd><p class="startdd"><code>&lt;Full, Recurrent, Orbit, PrimePower&gt;</code><br  />
Indicates whether to analyze the lattice generated by all possible states, or a sublattice generated by the set of recurrent states or by a subcycle of the generator.</p>
<p class="interdd"></p>
<dl>
<dt><code>Full</code>: </dt>
<dd>The complete lattice, generated by all possible initial states, will be analyzed.  </dd>
<dt><code>Recurrent</code>: </dt>
<dd>If the (combined) generator has transient states, then the lattice analyzed will be the sublattice generated by the set of recurrent states.  </dd>
<dt><code>Orbit</code>: </dt>
<dd>The grid generated by the (forward) orbit of a state of the (combined) generator is analyzed. This state is specified as follows. On the following \(J\) lines, the initial state for each component must be given. This is an integer vector with a number of components equal to the order of the component.  </dd>
<dt><code>PrimePower</code>: </dt>
<dd>In the case where some component is an MLCG whose modulus is a power of a prime \(p\), then the states visited over a single orbit (subcycle) of that component generate a sublattice (when \(a \equiv1 \bmod p\)) or belong to the union of \(p-1\) sublattices (otherwise). If <em>LatticeType</em> takes this value, if a component is an MLCG ( \(k=1\)), and if the modulus of that MLCG is given in the data file in the form (b):  \((x e
z)\) with \(z=0\) and \(x\) prime, then what is analyzed is one of those sublattices. This is done by dividing the modulus by the appropriate power of \(p\), as described in <b>[rLEC94e]</b>&thinsp;. For example, if \(p=2\) and \(a \mod8 = 5\), then the modulus is divided by 4 as in <b>[rFIS90a]</b>, <b>[rKNU81a]</b>&thinsp;.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt><code>LacGroupSize LacSpacing</code>: </dt>
<dd><p class="startdd"><code>&lt;int&gt; &lt;int&gt;</code><br  />
These data fields are positive integers, used to introduce lacunary indices. If the respective values are \(s\) and \(d\), then we will analyze the lattice structure of vectors of the form  \((u_{i+1}, …,
u_{i+s}, u_{i+d+1},…, u_{i+d+s}, u_{i+2d+1},…, u_{i+2d+s}, …)\), formed by groups of \(s\) successive values, taken \(d\) values apart. To analyze vectors of successive values (as usual), take \(s=d=1\). or \(s\) larger or equal to <em>MaxDim</em>. To analyze lacunary indices that are not evenly spaced, put \(s = -t\) where <em> \(t=\)MaxDim</em> and then, on the \(t\) lines that follow, give the \(t\) lacunary indices \(i_1,…,i_t\). . </p>
<p class="enddd"></p>
</dd>
<dt><code>MaxNodesBB</code>: </dt>
<dd><p class="startdd"><code>&lt;int&gt;</code><br  />
An integer giving the maximum number of nodes to be examined in any given branch-and-bound procedure when computing \(d_t\) or \(q_t\). When that value is exceeded, the branch-and-bound is stopped and the generator is rejected. The number of generators rejected for that reason is given in the results. A smaller value of <code>MaxNodesBB</code> will make the program run faster (sometimes much faster), permitting to examine more generators, but will increase the chances of rejecting good generators. </p>
<p class="enddd"></p>
</dd>
<dt><code>Duration Unit</code>: </dt>
<dd><p class="startdd"><code>&lt;double&gt; &lt;s, m, h, d&gt;</code><br  />
A real number followed by a letter, giving the maximal CPU time given to the program for performing its search. The <code>unit</code> must be one of <em>s, m, h, <em>or</em> d</em> for seconds, minutes, hours, and days, respectively. When the CPU time exceeds this duration, the partial results are printed, with a message. For a random search, the number of subregions printed includes the last region searched (whose search may not be finished). </p>
<p class="enddd"></p>
</dd>
<dt><code>S</code>: </dt>
<dd><p class="startdd"><code>&lt;int&gt;</code><br  />
Seed of the generator used for the random search. To perform a different random search in a region already studied, just change the seed. One must have \(S&gt; 0\). </p>
<p class="enddd"></p>
</dd>
<dt><code>OutputType</code>: </dt>
<dd><p class="startdd"><code>&lt;Terminal, RES, GEN&gt;</code><br  />
Selects in which form the results will be given. Lowercases are also allowed.</p>
<dl>
<dt><code>Terminal</code>: </dt>
<dd>indicates that the results will appear only on the terminal screen.  </dd>
<dt><code>RES</code>: </dt>
<dd>says that the results will be in a file with the same name as the data file, but with extension <code>".res"</code>.  </dd>
<dt><code>GEN</code>: </dt>
<dd>says that the retained generators will be listed in a file with the same name as the data file, with extension <code>".gen"</code>. This file can then be taken as input to the same program, for example to perform a second pass with a more stringent criterion or to compute higher dimensional lattice "measures" for the retained generators.  </dd>
</dl>
</dd>
</dl>
<h2><a class="anchor" id="output_seek"></a>
The output files</h2>
<p>A section describing how to read the output files. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jul 18 2025 21:40:38 for LatMRG API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
