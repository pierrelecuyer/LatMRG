<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatMRG API Documentation: Theory of Random Numbers</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatMRG API Documentation<span id="projectnumber">&#160;unknown</span>
   </div>
   <div id="projectbrief">Tools to analyze the lattice structure of linear generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d2d/background.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Theory of Random Numbers</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page covers the theory specific to <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> in two main sections and a third secondary one. First, we present all the generators engines covered by the library. Along with the generators definitions, we present the equivalences that make it possible to study all those generatorse in <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a>. In the second section, we present the construction of lattices for such random generators, as well as the computations to study such lattices. In the last section, we present some issues arrising when choosing parameters for a generator. This is an optionnal section that can be helpfull when starting searches with <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a>.</p>
<h1><a class="anchor" id="back_gen"></a>
Linear Congruential Engines</h1>
<h2><a class="anchor" id="back_gen_gen"></a>
Simple Congruential Generators</h2>
<p>We assume some familiarity with the concept of random number generator from from the reader. If this is not the case, we recommend reading the beginning of <b>[rLEC17h]</b>. Although this is not the shortest introduction to random number generators, it is very well suited for beginners and it covers both historical and modern issues of random number generation.</p>
<p>We first present the oldest and simplest generator engine that <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> covers. Given \(a,m,c \in \mathbb{Z}\), usually also with the constraints \(0 &lt; a &lt; m\) and \(0 \leq c &lt; m,\ 1 \equiv c \pmod 2\), we can get pseudo-random number in \((0,1)\) by generating the sequence \(\{x_n\}\)   </p><p class="formulaDsp">
\[
  x_n = a x_{n-1} + c \pmod m
\]
</p>
<p> and by taking the output of \(u_n = x_n / m\). Note that if \(c = 0\), the components also need to be such that \(\gcd(a,m) = 1\).</p>
<p>This kind of generator is called a <b>linear congruential generator</b> LCG. It is easy to implement and runs fast. But as computing power grew, It became clear that it was not practical to have a LCG as a random number generator. These generator have a high correlation between their points. It is also impractical to make on with a long enough period as the maximal possible period for a LCG is \(m-1\).</p>
<p>The natural extension of this engine that arose was the augmentation of the order of the recurrence as follows:   </p><p class="formulaDsp">
\[
  x_n = a_1 x_{n-1} + \cdots + a_k x_{n-k} \pmod m
\]
</p>
<p> where \(a_k \neq 0\). This engine can output random numbers in the same way by taking \(u_n = x_n / m\). Using this kind of recurrence mostly solves the problems of LCGs as it increases the states space considerably. This kind of engine is called a <b>multiple recursive generator</b> (MRG). Note that LCG generators simply are a specific case of MRG generators. It turns out that most of the generators presented after this point are equivalent to a MRG in some way and can be considered simply as MRGs when developping the theory. This is for this reason that this software is called <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a>. <a class="el" href="#back_other">Lattices and Merit</a> presents the main results to study a MRG, but they also have been broadly studied in the litterature in, for example, <b>[rLEC93a]</b> <b>[rLEC88a]</b>, and <b>[rLEC97b]</b>.</p>
<h2><a class="anchor" id="back_gen_carry"></a>
Carry Generators</h2>
<p>Using a MRG is much slower that using a LCG so many avenues have been studied as a way to generate random numbers on a period large enough to be useable, but that is faster than an MRG. This is what <b>[rMAR91a]</b> introduced. These engines are fast and also have long periods and use the following recurrences with \(r &gt; s\) and \(b \in \mathbb{Z}_{&gt;0}\):            </p><p class="formulaDsp">
\[
  \begin{array}{llll}
    \text{(AWC)} &amp; x_n &amp; = &amp; x_{n-s} + x_{n-r} + c_n \pmod b, \\
    &amp; c_{n+1} &amp; = &amp; \mathbb{1}(x_{n-s} + x_{i-r} + c_n \geq b). \\
    \text{(AWC-c)} &amp; x_n &amp; = &amp; -x_{n-s} - x_{n-r} - c_n - 1 \pmod b,\\
    &amp; c_{n+1} &amp; = &amp; \mathbb{1}(x_{n-s} + x_{i-r} + c_n \geq b).\\
    \text{(SWB-I)} &amp; x_n &amp; = &amp; x_{n-s} - x_{n-r} - c_n \pmod b,\\
    &amp; c_{n+1} &amp; = &amp; \mathbb{1}(x_{n-s} - x_{n-r} - c_n &lt; 0).\\
    \text{(SWB-II)} &amp; x_n &amp; = &amp; - x_{n-s} + x_{n-r} - c_n \pmod b,\\
    &amp; c_{n+1} &amp; = &amp; \mathbb{1}(x_{n-s} - x_{n-r} - c_n &lt; 0).\\
  \end{array}
\]
</p>
<p> These generators are called Add-with-Carry (AWC) and Subtract-with-Borrow (SWB) (we follow the naming scheme of <b>[rTEZ93a]</b> for the variants). The fact that these generators do not need multiplication operations mean that they will be very fast with b as a power of 2. With a good choice of parameters, the period of the recurrence can be up to around \(b^r\), which means that this generator solves both the period length problem and the speed one.</p>
<p>The sequence \(\{x_n\}\) can be used to generate random \(\mathcal{U}(0,1)\) numbers with an arbitrary number of digits in base \(b\) with   </p><p class="formulaDsp">
\[
  u_n = \sum_{j=1}^L x_{Ln + j + 1} b^{-j}.
\]
</p>
<p> By taking \(M\) as follows, </p><center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Generator   </th><th class="markdownTableHeadCenter">M    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">AWC   </td><td class="markdownTableBodyCenter">\(b^r+b^s-1\)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">AWC-c   </td><td class="markdownTableBodyCenter">\(b^r+b^s+1\)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">SWB-I   </td><td class="markdownTableBodyCenter">\(b^r-b^s+1\)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SWB-II   </td><td class="markdownTableBodyCenter">\(b^r-b^s-1\)   </td></tr>
</table>
</center><p> We can build an equivalence between AWC/SWB generators and the following LCG (<b>[rTEZ93a]</b>)     </p><p class="formulaDsp">
\begin{align}
  X_n &amp; = AX_{n-1} \pmod M \\
  v_n &amp; = X_n / M \\
  w_n &amp; = X_{Ln}/M.
\end{align}
</p>
<p> When we say equivalence, this is in the sense that, with the right initial state, the output \(w_i\) and \(u_i\) have the same decimal digits in base \(b\) up to the precision of \(u_i\). That is: \(u_i = b^{-L} \lfloor b^L w_i \rfloor\).</p>
<p>It turns out that AWC/SWB generators have a few faults in theoretical tests. <b>[rMAR94a]</b> suggested a similar kind of recurrence to solve this issue called <b>multiply-with-carry</b> (MWC)      </p><p class="formulaDsp">
\[
  \begin{array}{lll}
    x_n &amp; = &amp; (a_1 x_{n-1} + \cdots + a_k x_{n-k} + c_{n-1})d \pmod b,\\
    c_n &amp; = &amp; \lfloor (a_0 x_n + a_1 x_{n-1} + \cdots + a_k x_{n-k})/b\rfloor,
  \end{array}
\]
</p>
<p> where \(\gcd(a_0, b) = 1\) and \(1 \equiv -a_0d \pmod b\). This engine uses the same output function as AWC/SWB generators   \(
  u_n = \sum_{j=1}^L x_{Ln + j + 1} b^{-j}
\) and the results of <b>[rTEZ93a]</b> can be tweaked as in <b>[rCOU97a]</b>. Take \(M = \sum_{l = 0}^k a_k b^l\) and \(0 &lt; A &lt; m\) with \(1 \equiv Ab \pmod m\), then the same recurrence     </p><p class="formulaDsp">
\begin{align}
  X_n &amp; = AX_{n-1} \pmod M \\
  v_n &amp; = X_n / M \\
  w_n &amp; = X_{Ln}/M.
\end{align}
</p>
<p> is equivalent to the MWC generator with the same precision: \(u_i = b^{-L} \lfloor b^L w_i \rfloor\).</p>
<h2><a class="anchor" id="back_gen_comb"></a>
Combined Generators</h2>
<p>Generators using a carry can easily be constructed to have a large period and to operate very fast, but the fact that they are equivalent to LCGs means that their structure is most of the time flawed, especially in 2 dimensions. To solve this problem, it was suggested to use multiple MRGs and to combine their output. This reduces the computing cost of big MRGs, while obtaining much better distribution than carry generators.</p>
<p>Let sequences \(\{\{x_n^{(1)}\},\{x_n^{(2)}\},\ldots,\{x_n^{(\ell)}\}\}\) and \(\{\{u_n^{(1)}\},\{u_n^{(2)}\},\ldots,\{u_n^{(\ell)}\}\}\) be produced by MRGs with \(a_{i,j}\) the j-th coefficient of the i-th recurrence, \(k_i\) the order of the i-th recurrence and \(m_i\) the modulus of the i-th recurrence. It is possible to get pseudo-random numbers as:      </p><p class="formulaDsp">
\[
  \begin{array}{lll}
    \tilde{u}_n &amp; = &amp; \left(\sum_{i = 1}^\ell \delta_{i} x_n^{(i)} \pmod {m_1} \right) / m_1 \\
    w_n &amp; = &amp; \sum_{i = 1}^\ell \frac{\delta_{i} x^{(i)}_n}{m_i} \pmod 1.
  \end{array}
\]
</p>
<p><b>[rLEC96b]</b> presents a way to build a MRG that has an output \(\{u_n\}\) identical to \(\{w_n\}\) if their first \(k = \max(k_1, \ldots, k_\ell)\) output values are the same. Define      </p><p class="formulaDsp">
\begin{align}
  m &amp; = \prod_{i = 1}^\ell m_i \\
  b &amp; = \sum_{i=1}^\ell \frac{\delta_i b_i m}{m_i} \pmod m \\
  n_j &amp; \text{with } 1 \equiv n_j (m /m_j) \pmod {m_j},\ 1 \leq j \leq \ell \\
  a_j &amp; = \sum_{i=1}^\ell \frac{a_{i,j} n_i m}{m_i} \pmod m,\ 1 \leq j \leq k.
\end{align}
</p>
<p> Then if \((u_0, \ldots, u_{k-1}) = (w_0, \ldots, w_{k-1})\), then \(w_n = u_n\) for all \(n\in\mathbb{N}\) given    </p><p class="formulaDsp">
\begin{align}
  x_n &amp; = a_1 x_{n-1} + \cdots + a_k x_{n-k} + b \pmod m \\
  u_n &amp; = x_n/m.
\end{align}
</p>
<h2><a class="anchor" id="back_gen_mat"></a>
Matrix Generators</h2>
<p>The final type of generator that we present is slightly different. This is because it cannot be transformed to an equivalent MRG. Instead, this is a generalization of an MRG.</p>
<p>Take \(\mathbf{A}\in \mathbb{Z}^{k\times k}\) and \(s_n \in \mathbb{Z}^k\). We can generate a random number vector with   </p><p class="formulaDsp">
\[
  s_n = \mathbf{A} s_{n-1} \pmod m
\]
</p>
<p> and \(\mathbf{u}_n = (1/m) \cdot s_n\). This is what we call a <b>matrix multiple recursive generator</b> (MMRG). This kind of generator can also be used to generate any size of vector, including single random numbers. Let \(\mathbf{u}_n(i)\) be the i-th component for vector \(\mathbf{u}_n\) and \(p = qk + r,\ 0 \leq r &lt; k\) be the size of vectors wanted. We can get the random vector sequence  \(\{v_n = (\mathbf{u}_{n(q+1)}(1), \ldots, \mathbf{u}_{n(q+1)}(k), \ldots,
\mathbf{u}_{n(q+1)+q}(1), \ldots, \mathbf{u}_{n(q+1)+q}(r)) \in \mathbb{Z}^p\}\).</p>
<p>We will see below that a MRG of order \(k\) with multipliers \((a_1, \ldots, a_k)\) and modulo \(m\) has the same output structure as a MMRG with         </p><p class="formulaDsp">
\[
  \mathbf{A} = \begin{bmatrix}
        0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; \ddots &amp; 0 \\
        \vdots &amp;  &amp; \ddots &amp; \ddots &amp; \vdots \\
        0 &amp; \cdots &amp; \cdots &amp; 0 &amp; 1 \\
        a_1 &amp; a_2 &amp; \cdots &amp; \cdots &amp; a_k
      \end{bmatrix}^k
\]
</p>
<h1><a class="anchor" id="back_other"></a>
Lattices and Merit</h1>
<p>As explained in lattice_back, lattices of dimension \(t\) are discrete subgroups of \(\mathbb{R}^t\) generated by the integer combinations of a set of linearly independant (over the integers) vectors. We now explain how random number generators of the MRG familly can be studied from the lattice of their points, and how to obtain the lattice of these generators.</p>
<h2><a class="anchor" id="back_lat"></a>
Lattice of a MRG</h2>
<p>Take </p><p class="formulaDsp">
\[\Psi_t = \{ \mathbf{u}_0 =(x_0 /m, \ldots, x_{t-1}/m): (x_0, \dots, x_{k-1}) \in \mathbb{Z}_m^k\}\]
</p>
<p> for a MRG of order \(k\). This is the set of all first \(t\) components vectors the generator will output. The periodic contination of this set is a lattice. We will name this lattice \(L_t\), thus   </p><p class="formulaDsp">
\[
  \Psi_t + \mathbb{Z}^t = L_t.
\]
</p>
<p> This lattice has basis          </p><p class="formulaDsp">
\[
  \mathbf{V} = \begin{pmatrix}
    1/m &amp; 0 &amp; \dots &amp; 0 &amp; x_{1,k+1} &amp; \dots &amp; x_{1,t} \\
    0 &amp; 1/m &amp; \dots &amp; 0 &amp; x_{2,k+1} &amp; \dots &amp; x_{2,t} \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\
    0 &amp; 0 &amp; \dots &amp; 1/m &amp; x_{k,k+1} &amp; \dots &amp; x_{k,t} \\
    0 &amp; 0 &amp; \dots &amp; 0 &amp; 1 &amp; \dots &amp; 0 \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    0 &amp; 0 &amp; \dots &amp; 0 &amp; 0 &amp; \dots &amp; 1 \end{pmatrix}
\]
</p>
<p> and its dual has basis          </p><p class="formulaDsp">
\[
  \mathbf{W} = \begin{pmatrix}
    m &amp; 0 &amp; \dots &amp; 0 &amp; 0 &amp; \dots &amp; 0 \\
    0 &amp; m &amp; \dots &amp; 0 &amp; 0 &amp; \dots &amp; 0 \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\
    0 &amp; 0 &amp; \dots &amp; m &amp; 0 &amp; \dots &amp; 0 \\
    -x_{1,k+1} &amp; -x_{2,k+1} &amp; \dots &amp; -x_{k,k+1} &amp; 1 &amp; \dots &amp; 0 \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    -x_{1,t} &amp; -x_{2,t} &amp; \dots &amp; -x_{k,t} &amp; 0 &amp; \dots &amp; 1 \end{pmatrix}.
  \]
</p>
<p> Where \(x_{i,j}\) is the \(j\)-th x value of the generator with initial state \( \mathbf{e}_i = (0, \dots, 1, \dots, 0) \in \mathbb{Z}^k\), the \(i\)-th canonical vector in dimension \(k\). <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> can build this lattice for any of the generators mentioned.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Lacunary indices</h2>
<p>Instead of forming vectors with successive values like in the above definition of \(\Psi_t\), one can form vectors with values that are some distance apart in the sequence (so-called "leapfrog" values). a set of fixed integers. Define   </p><p class="formulaDsp">
\[
  \Psi_t(I) = \{(u_{i_1},…,u_{i_t}) \mid(x_0,…,x_{k-1}) \in\mathbb{Z}_m^k\}
\]
</p>
<p> and let \(L_t(I) = \Psi_t(I) + \mathbb{Z}^t\). If we assume that \(0\le i_1 &lt; i_2 &lt; \cdots&lt; i_t\), this \(L_t(I)\) is the projection of the lattice \(L_{i_t+1}\) over the \(t\)-dimensional subspace determined by the coordinates that belong to \(I\). For \((i_1,…,i_t) = (0,…,t-1)\), one has \(L_t(I) = L_t\). Using what is available in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a></em> one can build a basis for \(L_t\) and its dual in this more general case. This means <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> can perform the usual lattice analysis on these kind of lattice also. Further details and examples are given in <b>[rLEC97c]</b>.</p>
<h2><a class="anchor" id="back_merit"></a>
Measures on MRGs</h2>
<p>The lattice structure also means that all points of \(L_t\) lie in a family of equidistant parallel hyperplanes. Examining geometrical properties of these hyperplanes provides information on the uniformity of of the random numbers generated. Another important property that can be used to study of MRGs is their period length. Although a long period does not garantee good uniformity, it is ideal for better distribution properties.</p>
<h3><a class="anchor" id="back_merit_per"></a>
Period Length</h3>
<h3><a class="anchor" id="back_merit_spectral"></a>
Figures of Merit</h3>
<p>Among all such families hyperplanes that cover all the points, choose the one for which the successive hyperplanes are farthest apart. The distance between these successive hyperplanes is equal to \(1/\ell_t\) where \(\ell_t\) is the Euclidean length of the shortest nonzero vector in the <em>dual</em> lattice \(L_t^*\). It is possible to normalize this value, such as to obtain the <em>spectral test</em> for the lattice.</p>
<p>To build figures of merit from the spectral test, we take the worst-case value of \(\ell_t/\ell_t^*(m^k)\) over certain values of \(t\) and for selected projections on lower-dimensional subspaces. More specifically, let \(\ell_I\) denote the length of the shortest nonzero vector \(\mathbf{v}\) in \(L_t^*(I)\), and  \(\ell_t =
\ell_{\{1,…,t\}}\) as before. For arbitrary positive integers \(t_1\ge\cdots\ge t_d \ge d\), consider the worst-case figure of merit   </p><p class="formulaDsp">
\[
  M_{t_1,…,t_d} = \min\left[ \min_{k+1\le t\le t_1} \ell_t/\ell_t^*(m^k),\min_{2\le s\le k} \min_{I\in S(s,t_s)} \ell_I/m, \min_{k+1\le s\le d} \min_{I\in S(s,t_s)} \ell_I/\ell_s^*(m^k) \right],
\]
</p>
<p> where  \(S(s,t_s) = \{I=\{i_1,…,i_s\} \mid1 = i_1 &lt;
\cdots&lt; i_s\le t_s\}\). This figure of merit makes sure that the lattice is good in projections over \(t\) successive dimensions for all \(t\le t_1\), and over non-successive dimensions that are not too far apart. Note that when \(s\le k\), the smallest distance between hyperplanes that can be achieved in \(s\) dimensions for the MRG is \(1/m\) because it is possible for the generator to span all points with coordinates \(z/m\) with \(z\in \mathbb{Z}\).</p>
<p>The figure of merit  \(M_{t_1} =
\min_{2\le s\le t_1} \ell_s/\ell_s^*(n)\) (with \(d=1\)) has been widely used for ranking and selecting LCGs and MRGs <b>[sFIS96a]</b>, <b>[rLEC99b]</b>, <b>[rLEC99c]</b>. The quantity \(M_{t_1,…,t_d}\) is a worst case over  \((t_1-d) +
\sum_{s=2}^d \binom{t_s-1}{s-1}\) projections, and this number increases quickly with \(d\) unless the \(t_s\) are very small.</p>
<p>When too many projections are considered, there are inevitably some that are bad. The worst-case figure of merit is (practically) always small, and cannot distinguish between good and mediocre behavior in the most important projections. Moreover, the time to compute \(M_{t_1,…,t_d}\) increases with the number of projections. We therefore suggest considering only the projections deemed important when first comparing generators. It is then possible to compare good generators for those projections more extensively. We suggest using the criterion with \(d\) equal to 4 or 5, and \(t_s\) decreasing with \(s\).</p>
<p>Instead of considering the shortest nonzero vector in the dual lattice, one can consider the shortest nonzero vector in the primal lattice \(L_t\). Its length represents the distance to the nearest other lattice point from any point of the lattice. A small value means that many points are placed on the same line, at some fixed distance apart.</p>
<h2><a class="anchor" id="minkowski"></a>
Minkowski reduced basis</h2>
<p>Another way of measuring the quality of a lattice is in terms of the relative lengths of the smallest and largest vectors in a <em>reduced</em> basis. It has been historicaly important to use this ratio for a Minkowski-reduced basis (MRLB) (see <b>[rAFF85a]</b>, <b>[rAFF88a]</b>, <b>[rGRO88a]</b> for more details). Roughly, a MRLB is a basis for which the vectors are in some sense the most orthogonal.</p>
<p>The ratio of the sizes of the shortest and longest vectors of a MRLB is called its <em>Beyer-quotient</em>. In general, a given lattice may have several MRLBs, all with the same length of the shortest vector, but perhaps with different lengths of the longest vector, and thus different Beyer quotients. We define \(q_t(I)\) as the maximum of the Beyer quotients of all MRLBs of \(L_t(I)\), and denote \(q_t(\{1,…,t\})\) by \(q_t\). We prefer values of \(q_t(I)\) close to 1. Similar to \(M_{t_1,…,t_d}\), we define   </p><p class="formulaDsp">
\[
    Q_{t_1,…,t_d} = \min\left[ \min_{k+1\le t\le t_1} q_t,\min_{2\le s\le d} \min_{I\in S(s,t_s)} q_t(I) \right]. \tag{Q}
  \]
</p>
<p>Since computing \(q_t\) is much more time consuming than computing the spectral test and this mesure is not unique, this test is seldom used nowadays.</p>
<h1><a class="anchor" id="back_param"></a>
A Good Parameter Choice</h1>
<p>The choice of modulo is a recurrent source of discussion when building such generators. This is because a modulo operation takes a variable time for variable modulus. Most of the time, there is a compromise to do between simple modulus like \(2^q\) (which can be computed with a simple xor operation) and \(p\) big prime number. The former is much faster to compute, but the latter usually performs much better in theoretical and statistical tests.</p>
<h1><a class="anchor" id="numbers_sec"></a>
Large numbers, matrices and polynomials</h1>
<p><a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This has to be redone in a way similar to Rank1Lattice.">LatMRG</a> can deal with very large moduli and multipliers. There is no limit on size other than the size of the computer memory (and the CPU time). For example, a generator with a modulus of a few hundred bits can be analyzed easily. Operations on large integers are performed using the GNU multi-precision package GMP <b>[iGMP06a]</b>. GMP is a portable library written in C for arbitrary precision arithmetic on integers, rational numbers, and floating-point numbers. For vectors, matrices of large numbers and polynomials, we use <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> <b>[iSHO05a]</b>. <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> is a high-performance, portable C++ library providing data structures and algorithms for manipulating arbitrary length integers, and for vectors, matrices, and polynomials over the integers and over finite fields. <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> uses GMP as an underlying package for dealing with large numbers.</p>
<p>Of course, arithmetic operations with these structures are performed in software and are significantly slower than the standard operations supported by hardware. For this reason, most of the basic (low-level) operations required by our higher-level classes have been implemented in two or three versions. When building a basis or checking maximal period conditions, the modulus and multipliers can be represented either as <code>int64_t</code>’s (64-bit integers) or <code>ZZ</code>’s (arbitrary large integers). After a lattice basis and its dual have been constructed, when working on the basis (finding a shortest vector, Minkowski reduction, etc.), the vector elements can be represented either as <code>double</code>’s (64-bit floating-point numbers) or <code>RR</code>’s (arbitrary large floating-point numbers).</p>
<p>When performing a search for good generators, for instance, one can first perform all the "screening" computations (involving many generators) using standard type <code>int64_t</code>, and then recompute (verify) with the large floating-point numbers <code>RR</code> only for the retained generators.</p>
<p><b>Beware!</b> A lot of the manipulations needed for 64 bits generators need more that 64 bits. Using <code>int64_t</code> to search and test 64 bits generators might cause overflows. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jul 18 2025 21:40:38 for LatMRG API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
